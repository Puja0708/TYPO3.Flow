<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Component Framework</title>

  <para>All objects are controlled centrally by the Component Framework. It
  implements the <firstterm>Inversion of Control</firstterm>
  (<acronym>IoC</acronym>) principle and provides some additional features
  such as a caching mechanism for objects. Because all packages are built on
  this foundation it is important to understand the general idea of components
  and the container. This chapter introduces the basic principles behind the
  Component Manager.</para>

  <tip>
    <para>A very good start to understand the idea of Inversion of Control and
    <firstterm>Dependency Injection</firstterm> is reading <link
    xl:href="http://martinfowler.com/articles/injection.html">Martin Fowler's
    article</link> on the topic.</para>
  </tip>

  <section>
    <title>If you remember only one thing</title>

    <para>If the IoC principle, Dependency Injection and components are all
    new to you, you'll surely need some time getting used to these new
    approaches. But don't worry - you can even ignore the idea behind it and
    still produce acceptable code. If you remember only one thing about
    components, please let it be this section. There are a few rules you have
    to follow, even if you don't use the more advanced features.</para>

    <para><orderedlist>
        <listitem>
          <para><emphasis>Use <function>getComponent()</function> instead of
          the <function>new</function> operator!</emphasis></para>

          <para>The instantiation of classes must be handled by the
          <firstterm>Component Factory</firstterm>. Therefore if you have to
          instantiate a class or need an existing instance of a class, use the
          Component Factory for retrieving one:</para>

          <example>
            <title>Don't use the new operator</title>

            <programlisting language="php">   // Avoid this:
$myObject = new F3::MyPackage::MyClassName;</programlisting>
          </example>

          <example>
            <title>Ask the Component Factory instead</title>

            <programlisting language="php">namespace F3::MyPackage;

/**
 * A sample class
 */
class SomeClass {

   /**
    * @var F3::FLOW3::Component::FactoryInterface
    */
   protected $componentFactory;

   /**
    * Constructs this sample class
    *
    * @param F3::FLOW3::Component::FactoryInterface $componentFactory A reference to the component factory
    */
   public function __construct(F3::FLOW3::Component::FactoryInterface $componentFactory) {
      $this-&gt;componentFactory = $componentFactory;
   }

   /**
    * Just some method
    *
    * @return void
    */
   public function someFunction() {
      $myObject = $this-&gt;componentFactory-&gt;getComponent('F3::MyPackage::MyClassName');
   }
}</programlisting>
          </example>

          <para>In the above example you ask the Component Factory for the
          instance of <classname>F3::MyPackage::MyClassName</classname>. In
          order to get an instance of the Component Factory, just add a
          parameter to your class constructor as seen in the example - you
          will automatically get a reference
          <emphasis>injected</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Singletons and Prototypes</emphasis></para>

          <para>A <link
          xl:href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton</link>
          is the name of a Design Pattern which ensures that only one instance
          of a class exists at a time. In PHP you can implement the Singleton
          pattern by creating a function (usually called
          <function>getInstance()</function>), which returns a unique instance
          of your class. Although this way of implementing the Singleton will
          possibly not conflict with the Component Manager, it is counter
          productive to the integrity of the system and might raise problems
          with unit testing (sometimes the Singleton is referred to as a
          <emphasis>Anti Pattern</emphasis>).</para>

          <para>The Component Factory will, if not configured differently,
          <emphasis>always return a unique instance</emphasis> of a component.
          Therefore Singleton is the default behaviour! If you need a fresh
          instance of your class, you will have to configure the scope of it
          by adding some annotation to your class:</para>

          <example>
            <title>Sample scope annotation</title>

            <programlisting language="php">/**
 * This is my great class.
 *
 * @scope prototype
 */
class SomeClass {

}</programlisting>
          </example>
        </listitem>
      </orderedlist></para>
  </section>

  <section>
    <title>Components and containers</title>

    <para>The idea to segment software into reusable components which can be
    easily composed into a whole, is as old as software development itself. It
    is a tempting idea to just combine ready-made components instead of
    sorting out code from earlier projects which can hopefully be reused.
    Although the initial vision of mass-produced software with prefabricated
    components did not become reality, software componentry is undoubtedly a
    good thing, something you want your application framework to have support
    for.</para>

    <para>Since version 3.5, TYPO3 allows anyone to extend the built-in
    functionality by developing their own extensions. This plugin concept has
    proven to be very powerful and led to thousands of publicly available
    extensions contributed by our community. While a plugin based system is
    usually based on a monolithic core the plugins can hook onto, a component
    based system is only composed of components itself. FLOW3, the foundation
    of TYPO3 version 5, is a component based framework giving you lots of
    opportunities to cleanly extend and modify virtually any part of the
    system.</para>

    <section>
      <title>Components</title>

      <para>All PHP classes which are managed by the Component Manager are
      called Components. Because nearly all classes are managed by the
      Component Manager, almost all classes in FLOW3 - including third-party
      extensions - are used as components.<tip>
          <para>All classes which are found in the
          <filename>Classes</filename> directory of a package are
          automatically registered as components (See chapter <olink
          targetdoc="package-manager">Package Manager</olink>)</para>
        </tip></para>

      <para>In contrast to plain, standalone classes which are probably only
      used in a project or two, the development of reusable components
      requires the author to pay more attention on proper documentation,
      testing and encapsulation. If a component is well designed, it doesn't
      expose the internal functions and properties of the class but only
      allows access through a well-thought API. By following this
      blackbox-principle, it is much easier to modify the internal behaviour
      of a component at a later time, because it is always known which
      functions can be used from outside.</para>
    </section>

    <section>
      <title>Container</title>

      <para>In simple, self-contained applications, creating objects is as
      simple as using the <function>new</function> operator. However, as the
      program gets more complex, a developer is confronted with solving
      dependencies to other objects, make classes configurable (maybe through
      a factory method) and finally assure a certain scope for the object
      (such as <firstterm>Singleton</firstterm> or
      <firstterm>Prototype</firstterm>). <personname>
      <firstname>Howard</firstname> <othername>Lewis</othername>
      <surname>Ship</surname> </personname>explained this circumstances nicely
      in <link
      xl:href="http://tapestryjava.blogspot.com/2004/08/dependency-injection-mirror-of-garbage.html">his
      blog</link> (quite some time ago):</para>

      <blockquote>
        <para>Garbage collection is the last stage of an object's life cycle,
        but there's just as much going on at the start of the object's life
        cycle. That's why component frameworks and dependency injection
        containers (such as HiveMind, Spring, Picocontainer and Avalon) are so
        important.</para>

        <para>[...] Once you start thinking in terms of large numbers of
        objects, and a whole lot of just-in-time object creation and
        configuration, the question of <emphasis>how</emphasis> to create a
        new object doesn't change (that's what <function>new</function> is
        for) ... but the questions <emphasis>when</emphasis> and
        <emphasis>who</emphasis> become difficult to tackle. Especially when
        the <emphasis>when</emphasis> is very dynamic, due to just-in-time
        instantiation, and the <emphasis>who</emphasis> is unknown, because
        there are so many places a particular object may be used.</para>
      </blockquote>

      <para>We as PHP developers don't have to care about garbage collection
      and we surely wouldn't like to be responsible for it either. However,
      <emphasis>building</emphasis> objects can be even more complex than
      <emphasis>destructing</emphasis> them. Therefore the FLOW3 framework
      manages the whole lifecycle of components for you. The Component Manager
      is a so called <firstterm>Lightweight Container</firstterm> taking care
      of object building and dependency resolution. We'll discover shortly why
      dependency injection makes such a difference to your application
      design.</para>
    </section>

    <section>
      <title>Component Framework API</title>

      <para>The Component Framework provides a lean API for registering,
      configuring and retrieving instances of components. Some of the methods
      provided are exclusively used within the <package>FLOW3</package>
      package or in unit tests and should possibly not be used elsewhere. By
      offering Dependency Injection, the Component Framework helps you to
      avoid creating rigid interdependencies between components. It allows for
      writing code which is hardly or even not at all aware of the framework
      it is working in.</para>

      <para>Although Dependency Injection is what you should strive for, it
      might happen that you need to retrieve component instances directly.
      Instead of using PHP's <function>new</function> operator, you must ask
      the Component Factory for the instance of a component.</para>

      <para>First, you need an instance of the Component Factory itself and as
      you have seen in the shortcut example before, one way of getting it is
      adding a new parameter to your class constructor method:</para>

      <programlisting language="php">public function __construct(F3::FLOW3::Component::FactoryInterface $componentFactory) {
}</programlisting>

      <para>To explicitly retrieve the instance of a component use the
      <function>getComponent()</function> method:</para>

      <programlisting language="php">$myComponentInstance = $componentFactory-&gt;getComponent('F3::MyPackage::MyClassName');</programlisting>

      <para>It is possible to pass arguments to the constructor of the
      component class just by adding them to the
      <function>getComponent()</function> call:</para>

      <programlisting language="php">$myComponentInstance = $componentFactory-&gt;getComponent('F3::MyPackage::MyClassName', 'first argument', 'second argument');</programlisting>
    </section>

    <section>
      <title>Component names and types</title>

      <para>By default, the name of a component is identical to the PHP class
      which implements the component's functions. A class called
      <classname>F3::MyPackage::MyImplementation</classname> will be
      automatically available as a component with the exact same name. Every
      part of the system which asks for a component instance with a certain
      name will therefore - by default - get an instance of the class of that
      name. It is possible to replace the original implementation of a
      component by another one. In that case the class name of the new
      implementation will naturally differ from the component name which stays
      the same at all times.</para>

      <para>If the component name is the same as the name of a PHP interface,
      it is often referred to as a <emphasis>component type</emphasis>. An
      interface called
      <interfacename>F3::MyPackage::MyInterface</interfacename> will be
      available as a component name as long as there exists at least one class
      implemententing that interface.</para>
    </section>
  </section>

  <section>
    <title>Component dependencies</title>

    <para>The intention to base an application on a combination of packages
    and components is to force a clean separation of domains which are
    realized by dedicated components. The less each component knows about the
    internals of another component, the easier it is to modify or replace one
    of them, which in turn makes the whole system flexible. In a perfect
    world, each of the components could be reused in a variety of contexts,
    for example independently from the <package>TYPO3</package> package and
    maybe even outside the FLOW3 framework.</para>

    <section>
      <title>Dependency Injection</title>

      <para>An important prerequisite for resuable code is already met by
      encouraging encapsulation through the components approach. However, the
      components are still aware of their environment as they need to actively
      collaborate with other components and the framework itself: An
      authentication component will need a logger for logging intrusion
      attempts and the code of a shop system hopefully consists of more than
      just one class. Whenever a component refers to another directly, it adds
      more complexity and removes flexibility by opening new
      interdependencies. It is very difficult or even impossible to reuse such
      hardwired classes.</para>

      <para>By introducing <firstterm>Dependency Injection</firstterm>, these
      interdependencies are minimized by inverting the control over resolving
      the dependencies: Instead of asking for the instance of a component
      actively, the depending component just gets one
      <emphasis>injected</emphasis> by the Component Manager. This methodology
      is also referred to as the "<link
      xl:href="http://en.wikipedia.org/wiki/Hollywood_Principle">Hollywood
      Principle</link>": <quote>Don't call us, we'll call you.</quote>. It
      helps in the development of code with loose coupling and high cohesion –
      or in short: It makes you a better programmer.</para>

      <para>In the context of the previous example it means that the
      authentication component announces that it needs a logger which
      implements a certain PHP interface (eg. the
      <interfacename>F3::FLOW3::Log::LoggerInterface</interfacename>). The component
      itself has no control over what kind of logger (simple file logger,
      sms-logger, ...) it finally gets and it doesn't have to care about it
      anyway as long as it matches the expected API. As soon as the
      authentication component is instantiated, the component manager will
      resolve these dependencies, prepare an instance of a logger and inject
      it to the authentication component.</para>

      <tip>
        <para><link xl:href="http://www.ddj.com/dept/java/184405016">An
        article</link> by <personname> <firstname>Jonathan</firstname>
        <surname>Amsterdam</surname> </personname> discusses the difference
        between creating an object and requesting one (ie. using
        <function>new</function> versus using dependency injection). It
        demonstrates why <function>new</function> should be considered as a
        low-level tool and outlines issues with polymorphism. He doesn't
        mention dependency injection though ...</para>
      </tip>

      <para>Dependencies on other components can be declared in the components
      configuration (see section about configuring components) or they can be
      solved automatically (so called autowiring). Generally there are two
      modes of dependency injection supported by FLOW3: <firstterm>Constructor
      Injection</firstterm> and <firstterm>Setter
      Injection</firstterm>.</para>

      <section>
        <title>Constructor Injection</title>

        <para>With constructor injection, the dependencies are passed as
        constructor arguments to the depending component while it is
        instantiated. Here is an example of the authentication component which
        depends on a logger component:</para>

        <example>
          <title>A simple example for Constructor Injection</title>

          <programlisting language="php">public class LDAPAuthentication {

   protected $logger;

   public function __construct(F3::FLOW3::Log::LoggerInterface $logger) {
      $this-&gt;logger = $logger;
   }

   public function authenticate($credentials) {
      $this-&gt;logger-&gt;log('tried to authenticate');
   }
}</programlisting>
        </example>

        <para>So far there's nothing special about this class, it just makes
        sure that an instance of a class implementing the
        <interfacename>F3::FLOW3::Log::LoggerInterface</interfacename> is passed to
        the constructor. However, this is already a quite flexible approach
        because the type of logger can be determined from outside by just
        passing one or the another implementation to the constructor.</para>

        <para>Now the FLOW3 Component Manager does some magic: By a mechanism
        called <firstterm>Autowiring</firstterm> all dependencies which were
        declared in a constructor will be injected automagically if the
        constructor argument provides a type definition (ie.
        <classname>F3::FLOW3::Log::LoggerInterface</classname> in the above example).
        Autowiring is activated by default (but can be switched off),
        therefore all you have to do is to write your constructor
        method.</para>

        <para>The Component Factory can also be configured manually to inject
        a certain component or component type. You'll have to do that either
        if you want to switch off autowiring or want to specify a
        configuration which differs from would be done automatically.</para>

        <example>
          <title>Components.php file for Constructor Injection</title>

          <programlisting language="php">$c-&gt;F3_Authentication_LDAPAuthentication-&gt;
constructorArguments[1]-&gt;reference = 'F3::FLOW3::Log::ASpecialLogger';</programlisting>
        </example>

        <para>The two lines above define that a component instance of
        <interfacename>F3::FLOW3::Log::ASpecialLogger</interfacename> must be passed
        to the first argument of the constructor when an instance of the
        component
        <classname>F3::Authentication::LDAPAuthentication</classname> is
        created. Mind that in the configuration file the class name is written
        with underscores!</para>
      </section>

      <section>
        <title>Setter Injection</title>

        <para>With setter injection, the dependencies are passed by calling
        <firstterm>setter methods</firstterm> of the depending component right
        after it has been instantiated. Here is an example of the
        authentication component which depends on a logger component - this
        time with setter injection:</para>

        <example>
          <title>A simple example for Setter Injection</title>

          <programlisting language="php">public class LDAPAuthentication {

   protected $someLogger;

   public function authenticate($credentials) {
      $this-&gt;logger-&gt;log('tried to authenticate');
   }

   public function setSomeLogger(F3::FLOW3::Log::LoggerInterface $someLogger) {
      $this-&gt;someLogger = $someLogger;
   }
}</programlisting>
        </example>

        <para>Analog to the constructor injection example, a logger component
        is injected into the authentication component. In this case, however,
        the injection only takes place after the class has been instantiated
        and a possible constructor method has been called. The neccessary
        configuration for the above example looks like this:</para>

        <example>
          <title>Components.php file for Setter Injection</title>

          <programlisting language="php">&lt;?php

$c-&gt;F3_Authentication_LDAPAuthentication-&gt;properties-&gt;someLogger-&gt;reference = 'F3::FLOW3::Log::LoggerInterface';

?&gt;</programlisting>
        </example>

        <para>Unlike constructor injection, setter injection like in the above
        example does not offer the autowiring feature. All depedencies have to
        be declared explicitly in the component configuration. To save you
        from writing large configuration files, FLOW3 supports a second type
        of setter methods: By convention all methods whose name start with
        "inject" are considered as setters for setter injection. For those
        methods no further configuration is necessary, dependencies will be
        autowired (if autowiring is not disabled):</para>

        <example>
          <title>The preferred way of Setter Injection, using an inject
          method</title>

          <programlisting language="php">public class LDAPAuthentication {

   protected $someLogger;

   public function authenticate($credentials) {
      $this-&gt;logger-&gt;log('tried to authenticate');
   }

   public function injectSomeLogger(F3::FLOW3::Log::LoggerInterface $someLogger) {
      $this-&gt;someLogger = $someLogger;
   }
}</programlisting>
        </example>

        <para>Note the new method name
        <methodname>injectSomeLogger</methodname> - for the above example no
        further configuration is required (but possible). Using
        <methodname>inject*</methodname> methods is the preferred way for
        setter injection in FLOW3.</para>

        <note>
          <para>If both, a <methodname>set*</methodname> and a
          <methodname>inject*</methodname> method exist for the same property,
          the <methodname>inject*</methodname> method has precendence.</para>
        </note>

        <sidebar>
          <title>Constructor- or Setter Injection?</title>

          <para>The natural question which arises at this point is
          <quote>Should I use Constructor- or Setter Injection?</quote>. There
          is no answer across-the-board – it mainly depends on the situation
          and your preferences. The authors of the Java-based <link
          xl:href="http://www.springframework.org">Spring Framework</link> for
          example prefer Setter Injection for its flexibility. The more
          puristic developers of <link
          xl:href="www.picocontainer.org">PicoContainer</link> strongly plead
          for using Constructor Injection for its cleaner approach. If you
          have the choice, we suggest taking the latter, for the very same
          reasons the PicoContainer team gives:</para>

          <itemizedlist>
            <listitem>
              <para>Constructor Injection makes a stronger dependency
              contract</para>
            </listitem>

            <listitem>
              <para>It enforces a determinate state of the depending
              component: In the Setter Injection example above, the logger is
              only available after the constructor has been called
              already</para>
            </listitem>
          </itemizedlist>

          <para>However, there might be situations in which constructor
          injection is not possible or even cumbersome:</para>

          <itemizedlist>
            <listitem>
              <para>If a component has many dependencies and maybe even many
              optional depedencies, setter injection might be a better
              solution.</para>
            </listitem>

            <listitem>
              <para>Subclasses are not always in control over the arguments
              passed to the constructor or might even be incapable of
              overriding the original constructor (FLOW3's action controller
              is such a case). Then setter injection is your only chance to
              get dependencies injected.</para>
            </listitem>

            <listitem>
              <para>Setter injection can be helpful to avoid circular
              dependencies between components.</para>
            </listitem>
          </itemizedlist>
        </sidebar>
      </section>
    </section>

    <section>
      <title>Required and optional dependencies</title>

      <para>All dependencies defined in a constructor are, by its nature,
      required. If a dependency can't be solved by autowiring or by
      configuration, FLOW3's object builder will throw an exception.</para>

      <para>Also <emphasis>autowired setter-injected dependencies</emphasis>
      are, by default, required. There is a way to declare a setter-injected
      dependency as optional without the need to configure the dependency in a
      <filename>Components.php</filename> file. If an optional dependency
      can't be solved, it just won't be injected and it is the developer's
      responsability to test for the availability of the desired object. FLOW3
      uses the @optional annotation for this purpose:</para>

      <example>
        <title>Marking a setter-injected dependency as optional</title>

        <programlisting language="php">public class LDAPAuthentication {

   /**
    * @var F3::FLOW3::Log::LoggerInterface
    */
   protected $someLogger;

   /**
    * Show-off-method
    *
    * @param mixed $credentials
    * @return void
    */
   public function authenticate($credentials) {
      $this-&gt;logger-&gt;log('tried to authenticate');
   }

   /**
    * Injects a logger
    *
    * @param F3::FLOW3::Log::LoggerInterface $someLogger A logger which is used for logging LDAP authentication events
    * @return void
    * @author Robert Lemke &lt;robert@typo3.org&gt;
    * @optional
    */
   public function injectSomeLogger(F3::FLOW3::Log::LoggerInterface $someLogger) {
      $this-&gt;someLogger = $someLogger;
   }
}</programlisting>
      </example>

      <para>Due to the @optional annotation, the injection of a logger is now
      no longer required. If the component object builder can't autowire a
      logger for this injection method, it will now no longer throw an
      exception.</para>
    </section>

    <section>
      <title>Dependency resolution</title>

      <para>The dependencies between components are only resolved during the
      instantiation process. Whenever a new instance of a component class
      needs to be created, the component configuration is checked for possible
      dependencies. If there is any, the required components are built and
      only if all dependencies could be resolved, the component class is
      finally instantiated and the dependency injection takes place.</para>

      <section>
        <title>Circular dependencies</title>

        <para>During the resolution of dependencies it might happen that
        circular dependencies occur. If a component A requires a component B
        to be injected to its constructor and then again component B requires
        a component A likewise passed as a constructor argument, none of the
        two classes can be instantiated due to the mutual dependency. Although
        it is technically possible (albeit quite complex) to solve this type
        of reference, FLOW3's policy is not to allow circular dependencies at
        all. As a workaround you can use Setter Injection instead of
        Constructor Injection for either one or both of the components causing
        the trouble.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Configuring components</title>

    <para>The behaviour of components significantly depends on their
    configuration. During the initialization process all classes found in the
    various <filename>Classes/</filename> directories are registered as
    components and an initial configuration is prepared. In a second step,
    other configuration sources are queried for additional configuration
    options. Definitions found at these sources are added to the base
    configuration in the following order:</para>

    <orderedlist>
      <listitem>
        <para>If it exists, the file
        <filename><replaceable>PackageName</replaceable>/Configuration/Components.php</filename>
        will be included. PHP code in this file must follow the general rules
        for PHP configuration files in FLOW3.</para>
      </listitem>

      <listitem>
        <para>Additional configuration defined in the global
        <filename>Configuration/</filename> directory is applied.</para>
      </listitem>

      <listitem>
        <para>Additional configuration defined through the component manager
        user interface will be applied. <remark>This feature has not been
        implemented yet!</remark></para>
      </listitem>
    </orderedlist>

    <para>Currently there are three important situations in which you want to
    configure components:</para>

    <itemizedlist>
      <listitem>
        <para>Override one component implementation with another</para>
      </listitem>

      <listitem>
        <para>Set the active implementation for a component type</para>
      </listitem>

      <listitem>
        <para>Define dependencies to other components</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Configuration sources</title>

      <para>As already mentioned, the configuration for each component is
      compiled from different sources. The <filename>Components.php</filename>
      file is the recommended format and is therefore used in most of the
      examples. However, the names of the configuration options and their
      possible values are identical to all configuration sources.</para>

      <section>
        <title>Components.php</title>

        <para>If a file named <filename>Components.php</filename> exists in
        the <filename>Configuration</filename> directory of a package, it will
        be included during the configuration process (ie. before the first
        component class is instantiated!). The PHP file should stick to
        FLOW3's general rules for PHP-based configuration.</para>

        <para>The following code adds the same configuration as in the
        Constructor Injection example which will be used in the next
        sections:</para>

        <example>
          <title>Sample Components.php file</title>

          <programlisting language="php">&lt;?php
declare(ENCODING = 'utf-8');

/*                                                                        *
 * Component Configuration for the Authentication package                 *
 * (this package doesn't really exist, and even if so, the configuration  *
 * would probably be different)                                           *
 *                                                                        */

/**
 * @package Authentication
 * @version $Id: Components.php 123 2008-01-01 12:00:00Z robert $
 */

$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[1]-&gt;reference = 'F3::FLOW3::Log::LoggerInterface';
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[2]-&gt;reference = 'F3::LDAP::LDAPServerInterface';
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[3] = 'cn=John Smith,ou=TYPO3 Development,o=TYPO3 Association,c=CH';

?&gt;</programlisting>
        </example>

        <caution>
          <para>Only use these files for configuration, for example don't
          register autoloader methods in the
          <filename>Components.php</filename> as this code must be invoked in
          an earlier stage. The <filename>Package.php</filename> is the right
          place for registering autoloaders.</para>
        </caution>
      </section>

      <section>
        <title>Annotations</title>

        <para>A very convenient way to configure certain attributes of
        components are annotations. You write down the configuration directly
        where it takes effect: in the class file. However, this way of
        configuring components is not really flexible, as it is hard coded.
        That's why only those options can be set through annotations which are
        part of the class design and won't change afterwards. Currently
        <literal>scope</literal> is the only supported annotation.</para>

        <para>It's up to you defining the scope in the class directly or doing
        it in a Components.php file – both have the same effect. We recommend
        using annotations in this case, as the scope usually is a design
        decision which is very unlikely to be changed.</para>

        <example>
          <title>Sample scope annotation</title>

          <programlisting language="php">/**
 * This is my great class.
 *
 * @scope prototype
 */
class SomeClass {

}</programlisting>
        </example>
      </section>
    </section>

    <section>
      <title>Overriding components</title>

      <para>One advantage of componentry is the ability to replace components
      by others without any bad impact on those parts depending on them. A
      prerequisite for replaceable components is that their classes implement
      a common <link
      xl:href="http://www.php.net/manual/en/language.oop5.interfaces.php">interface</link>
      which defines the public API of the original component. Other components
      which implement the same interface can then act as a true replacement
      for the original component without the need to change code anywhere in
      the system. If this requirement is met, the only necessary step to
      replace the original implementation with a substitute is to alter the
      component configuration and set the class name to the new
      implementation.</para>

      <para>To illustrate this circumstance, consider the following
      classes:</para>

      <example>
        <title>A simple Greeter class</title>

        <programlisting language="php">namespace F3::MyPackage;

class Greeter {
   public function sayHelloTo($name) {
      echo('Hello ' . $name);
   }
}</programlisting>
      </example>

      <para>During initialization above class will automatically be registered
      as the component <classname>F3::MyPackage::Greeter</classname> and is
      available to other components. In the code of another component you
      might find these lines:</para>

      <example>
        <title>Code using the component F3_MyPackage_Greeter</title>

        <programlisting language="php">   // Explicitly fetch an instance of the F3::MyPackage::Greeter component:
$greeter = $componentManager-&gt;getComponent('F3::MyPackage::Greeter');

   // Say hello to Heike:
$greeter-&gt;sayHelloTo('Heike');
</programlisting>
      </example>

      <para>Great, that looks all fine and dandy but what if we want to use
      the much better component
      <classname>F3::OtherPackage::GreeterWithCompliments</classname>? Well,
      you just configure the component
      <classname>F3::MyPackage::Greeter</classname> to use a different
      class:</para>

      <example>
        <title>Components.php file for component replacement</title>

        <programlisting language="php">   # Change the name of the class which represents the component "F3::MyPackage::Greeter":
$c-&gt;F3_MyPackage_Greeter-&gt;className = 'F3::OtherPackage::GreeterWithCompliments';</programlisting>
      </example>

      <para>Now all components who ask for a traditional greeter will get the
      more polite version. However, there comes a sour note with the above
      example: We can't be sure that the
      <classname>GreeterWithCompliments</classname> class really provides the
      necessary <function>sayHello()</function> method. The solution is to let
      both implementations implement the same interface:</para>

      <example>
        <title>The Greeter component type</title>

        <programlisting>namespace F3::MyPackage;

interface GreeterInterface {
   public function sayHelloTo($name);
}

class Greeter implements F3::MyPackage::GreeterInterface {
   public function sayHelloTo($name) {
      echo('Hello ' . $name);
   }
}


namespace F3::OtherPackage;

class GreeterWithCompliments implements F3::MyPackage::GreeterInterface{
   public function sayHelloTo($name) {
      echo('Hello ' . $name . '! You look so great!');
   }
}</programlisting>
      </example>

      <para>Instead of referring to the original implementation directly we
      can now refer to the interface. In this case we call the component name
      a <emphasis>component type</emphasis> because it contains the name of a
      PHP interface.</para>

      <example>
        <title>Code using the component type
        F3::MyPackage::GreeterInterface</title>

        <programlisting>   // Explicitly fetch an instance of any implementation of the F3::MyPackage::GreeterInterface component type:
$greeter = $componentManager-&gt;getComponent('F3::MyPackage::GreeterInterface');

   // Say hello to Heike:
$greeter-&gt;sayHelloTo('Heike');</programlisting>
      </example>

      <para>Finally we have to set which implementation of the
      <interfacename>F3::MyPackage::GreeterInterface</interfacename> should be
      active:</para>

      <example>
        <title>Components.php file for component type definition</title>

        <para><programlisting>$c-&gt;F3_MyPackage_GreeterInterface-&gt;className = 'F3::OtherPackage::GreeterWithCompliments';</programlisting></para>
      </example>
    </section>

    <section>
      <title>Component types</title>

      <para>Any interface found in the <filename>Classes/</filename> directory
      will equally be registered as a component if at least one class within
      the same package was found that implements this interface. The first
      class found in the package which implements the interface is considered
      to be the default implementation and the component's
      <option>className</option> option is set accordingly. Of course it is
      still possible that the class name is defined explicitly in the
      package's <filename>Components.php</filename> file or any other
      configuration source. This is especially important if more than one
      implementing class exists.</para>
    </section>

    <section>
      <title>Injecting properties and constructor arguments</title>

      <para>As mentioned earlier, the Component Factory allows for injection
      of straight values or references (ie. dependencies) either by passing
      them as constructor arguments during instantiation of the component
      class or by calling a setter method which sets the wished property
      accordingly. The following sections demonstrate how to pass values and
      define dependencies to other components.</para>

      <section>
        <title>Straight values and references</title>

        <para>Regardless of what injection type is used, there are two kinds
        of value which can be injected:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Straight values</emphasis> are static values of a
            simple type. They can be strings, integers, booleans, array or
            even custom objects (ie. objects which are not handled by the
            Component Framework) and are passed on as they are.</para>
          </listitem>

          <listitem>
            <para><emphasis>References</emphasis> are names of components (or
            component types) which represent dependencies to other components.
            Dependencies are resolved and an instance of the component is
            passed along.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Constructor Injection</title>

        <para>The following class and the related
        <filename>Components.php</filename> file demonstrate the syntax for
        the definition of Constructor Injection:</para>

        <example>
          <title>Sample class for Constructor Injection</title>

          <para><programlisting language="php">public class LDAPAuthentication {

   protected $logger;
   protected $LDAPServer;
   protected $distinguishedName = '';

   public function __construct(F3::FLOW3::Log::LoggerInterface $logger, F3::LDAP::LDAPServerInterface $LDAPServer, $distinguishedName) {
      $this-&gt;logger = $logger;
      $this-&gt;LDAPServer = $LDAPServer;
      $this-&gt;distinguishedName = $distinguishedName;
   }

   public function authenticate(F3::Authentication::CredentialsInterface $credentials) {
      $this-&gt;LDAPServer-&gt;doSomeMagic($this-&gt;distinguishedName);
      $this-&gt;logger-&gt;log('tried to authenticate');
   }
}</programlisting></para>
        </example>

        <example>
          <title>Sample configuration for Constructor Injection</title>

          <programlisting language="php">  # Inject two component references as the first two arguments:
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[1]-&gt;reference = 'F3::FLOW3::Log::LoggerInterface';
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[2]-&gt;reference = 'F3::LDAP::LDAPServerInterface';

  # Inject a straight value as the third argument:
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[3] = 'cn=John Smith,ou=TYPO3 Development,o=TYPO3 Association,c=CH';</programlisting>
        </example>

        <note>
          <para>It is usually not necessary to configure injection of
          references explicitly. It is much more convent to just declare the
          type of the constructor arguments (like
          <interfacename>F3::FLOW3::Log::LoggerInterface</interfacename> and
          <interfacename>F3::LDAP::LDAPServerInterface in the above example)
          and let the Autowiring feature configure and resolve the
          dependencies for you.</interfacename></para>
        </note>
      </section>

      <section>
        <title>Setter Injection</title>

        <para>The following class and the related
        <filename>Components.php</filename> file demonstrate the syntax for
        the definition of Setter Injection:</para>

        <example>
          <title>Sample class for Setter Injection</title>

          <para><programlisting language="php">public class LDAPAuthentication {

   protected $logger;
   protected $LDAPServer;
   protected $distinguishedName = '';

   public function authenticate(F3::Authentication::CredentialsInterface $credentials) {
      $this-&gt;LDAPServer-&gt;doSomeMagic($this-&gt;distinguishedName);
      $this-&gt;logger-&gt;log('tried to authenticate');
   }

   public function injectLogger(F3::FLOW3::Log::LoggerInterface $logger) {
      $this-&gt;logger = $logger;
   }

   public function injectLDAPServer(F3::LDAP::LDAPServerInterface $LDAPServer) {
      $this-&gt;LDAPServer = $LDAPServer;
   }

   public function setDistinguishedName($distinguishedName) {
      $this-&gt;distinguishedName = $distinguishedName;
   }
}</programlisting></para>
        </example>

        <example>
          <title>Sample configuration for Setter Injection</title>

          <programlisting language="php">  # Inject two component references:
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;properties-&gt;logger-&gt;reference = 'F3::FLOW3::Log::LoggerInterface';
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;properties-&gt;LDAPServer-&gt;reference = 'F3::LDAP::LDAPServerInterface';

  # Inject a straight value as the third argument:
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;properties-&gt;distinguishedName = 'cn=John Smith,ou=TYPO3 Development,o=TYPO3 Association,c=CH';</programlisting>
        </example>

        <para>As you can see, it is important that a setter method with the
        same name as the property, preceded by "inject" or "set"
        exists.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Instantiating components</title>

    <para>In order to accomplish all the tasks connected with Dependency
    Injection and other advanced features, FLOW3 must take full control over
    the instantiation of the component classes. Usually it's sufficient to
    know that you have to either retrieve an instance manually with the
    <function>getComponent</function> method or get them injected by the
    Component Factory. From the component's point of view, a few options may
    be set to take influence on the instantiation of its class. This section
    explains these configuration options and finally outlines the
    instantiation process as a whole.</para>

    <section>
      <title>Scopes</title>

      <para>The objects created by the Component Factory all exist in a
      certain <firstterm>scope</firstterm>. By default, an instance of a
      component class is unique which makes sure that the exact same object is
      returned whenever the Component Factory is asked for a specific
      component. This default scope is called
      <firstterm>Singleton</firstterm>. Of course other scopes are supported
      as well:</para>

      <table>
        <title>Supported scopes</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">Scope</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>singleton (default)</entry>

              <entry>The component instance is unique during one request -
              each <function>getComponent call</function> returns the same
              instance. A request can be an HTTP request or a run initiated
              from the command line.</entry>
            </row>

            <row>
              <entry>prototype</entry>

              <entry>The component instance is not unique - each
              <function>getComponent call</function> returns a fresh
              instance.</entry>
            </row>

            <row>
              <entry>session <remark>Not yet implemented</remark></entry>

              <entry>The component instance is unique during the whole user
              session - each <function>getComponent</function> call returns
              the same instance.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>A great feature of the Component Framework is that components
      don't have to implement their own mechanism for administrating their
      scope - it only has to be configured. The following example contains
      configurations for three components, all living in a different
      scope:</para>

      <example>
        <title>Sample Components.php with different scopes</title>

        <para><programlisting language="php">$c-&gt;F3_MyPackage_ASingletonClass-&gt;scope = F3::FLOW3::Component::Configuration::SCOPE_SINGLETON;
$c-&gt;F3_MyPackage_APrototypeClass-&gt;scope = F3::FLOW3::Component::Configuration::SCOPE_PROTOTYPE;
$c-&gt;F3_MyPackage_ASessionClass-&gt;scope = F3::FLOW3::Component::Configuration::SCOPE_SESSION;</programlisting></para>
      </example>

      <note>
        <para>Unlike in the above example, the recommended way to define the
        scope of a component is the <property>@scope</property>
        annotation.</para>
      </note>
    </section>

    <section>
      <title>Passing constructor arguments</title>

      <para>In most cases a component class will live in the Singleton scope
      and at most requires a few dependencies passed to its constructor.
      However, there are times when it becomes necessary to pass dynamic
      values as constructor arguments, especially when the component
      represents an entity and its instances are not unique (Prototype scope).
      Consider the following classes:</para>

      <example>
        <title>A simple addressbook</title>

        <programlisting language="php">namespace F3::Address;

class Adressbook {

   protected $addresses = array();

   public __construct(F3::iCal::iCalConnectorInterface $iCalConnector) {
      ...
   }

   public addAddress(F3::Address::Address $address) {
      $this-&gt;addresses[] = $address;
   }

}

class Address {

   public __construct($street, $zip, $town, $country) {
      ...
   }
}</programlisting>
      </example>

      <para>This is admittedly not the fanciest implementation of an address
      book, but it should demonstrate two things:</para>

      <itemizedlist>
        <listitem>
          <para>The class <classname>F3::Address::Addressbook</classname> is
          supposed to be a Singleton and obviously depends on a third
          component type
          <classname>F3::iCal::iCalConnectorInterface</classname> which is
          possibly solved by Dependency Injection.</para>
        </listitem>

        <listitem>
          <para>The class <classname>F3::Address::Adress</classname>
          represents the address entity and its instances must not be unique -
          we surely want more than one address. The Address component also
          expects a few parameters passed to its constructor.</para>
        </listitem>
      </itemizedlist>

      <para>The following code demonstrates how this address book can be used
      and constructor arguments are passed to the Address entity:</para>

      <example>
        <title>Passing constructor arguments</title>

        <programlisting>   # Fetch a unique instance of the addressbook:
$myAddressbook = $componentManager-&gt;getComponent('F3::Address::Addressbook');

   # Create two new addresses and add them to the addressbook:
$newAddress = $componentManager-&gt;getComponent('F3::Address::Address', 'Tryggevældevej', '2720', 'København', 'DK');
$myAddresbook-&gt;addAddress($newAddress);

$newAddress = $componentManager-&gt;getComponent('F3::Address::Address', 'An den Brodbänken', '21335', 'Lüneburg', 'DE');
$myAddresbook-&gt;addAddress($newAddress);</programlisting>
      </example>
    </section>

    <section>
      <title>Autowiring</title>

      <para>Injecting dependencies to a constructor function is a common task.
      Because FLOW3 can detect the type of dependencies a constructor needs,
      it automatically configures the component to assert that the necessary
      components are injected. This automation is called
      <firstterm>autowiring</firstterm> and is enabled by default for every
      component. To repeat our favourite example, imagine that your component
      class needs some kind of logger. All you need to do in order to get one
      is writing the following constructor:</para>

      <example>
        <title>An autowired logger</title>

        <programlisting language="PHP">public function __construct(F3::FLOW3::Log::LoggerInterface $logger) {
   $logger-&gt;log("Hooray");
}</programlisting>
      </example>

      <para>The constructor of the above example will get an instance of the
      component of type
      <interfacename>F3::FLOW3::Log::LoggerInterface</interfacename> injected and can
      use it for further operations.</para>

      <para>If, for some reason, you need to disable autowiring support, you
      can do so by setting an option in your component configuration:</para>

      <example>
        <title>Turning off autowiring support in Components.php</title>

        <programlisting>$c-&gt;F3_MyPackage_MyComponent-&gt;autoWiringMode = FALSE;</programlisting>
      </example>
    </section>

    <section>
      <title>Lifecycle methods</title>

      <para>The lifecycle of a component object goes through different stages.
      It boils down to the following order:</para>

      <orderedlist>
        <listitem>
          <para>Solve dependencies for constructor injection</para>
        </listitem>

        <listitem>
          <para>Create an instance of the component class</para>
        </listitem>

        <listitem>
          <para>Solve and inject dependencies for setter injection</para>
        </listitem>

        <listitem>
          <para>Live a happy component-life and solve exciting tasks</para>
        </listitem>

        <listitem>
          <para>Dispose the component instance</para>
        </listitem>
      </orderedlist>

      <para>Your component might want to take some action after certain of the
      above steps. Whenever one of the following methods exists in the
      component class, it will be invoked after the related lifecycle
      step:</para>

      <orderedlist>
        <listitem>
          <para>No action after this step</para>
        </listitem>

        <listitem>
          <para>During instantiation the function
          <function>__construct()</function> is called (by PHP itself),
          dependencies are passed to the constructor arguments</para>
        </listitem>

        <listitem>
          <para>After all dependencies have been injected (through
          constructor- or setter injection) the component's initialization
          method is called. The name of this method is configurable (see
          below) and it is called regardless of whether any dependencies have
          been injected or not</para>
        </listitem>

        <listitem>
          <para>During the life of a component no special lifecycle methods
          are called</para>
        </listitem>

        <listitem>
          <para>On disposal, the function <function>__destruct()</function> is
          called (by PHP itself)</para>
        </listitem>
      </orderedlist>

      <para>As you can see from the above list, there is only one special
      method which is provided by PHP's own means and that is the
      initialization method. Here's a simple example:</para>

      <example>
        <title>A component class with an initialization method</title>

        <programlisting>class MyClass {

   protected $logger;

   public function __construct(F3::FLOW3::Log::LoggerInterface $logger) {
      $this-&gt;logger = $logger;
   }

   public function intializeComponent() {
      $this-&gt;logger-&gt;log('MyClass has been initialized.');
   }
}</programlisting>
      </example>

      <para>The above example will just work out of the box without any
      further configuration. However, if you don't have control over the name
      of your initialization method (maybe, because you are integrating legacy
      code), you can configure the name of the method in the component
      configuration:</para>

      <example>
        <title>Components.php configuration of the initialization
        method</title>

        <programlisting>$c-&gt;F3_MyPackage_MyClass-&gt;lifecycleInitializationMethod = 'myInitialize';</programlisting>
      </example>
    </section>
  </section>
</section>
