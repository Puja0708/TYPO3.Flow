<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:ns52="http://www.w3.org/1998/Math/MathML"
         xmlns:ns5="http://www.w3.org/1999/xlink"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>MVC Framework</title>

  <section>
    <title>Introduction</title>

    <section>
      <title>Model-View-Controller</title>

      <para>In the design of FLOW3's architecture we have taken great care to
      separate concerns and assign each part of the framework with
      well-defined tasks. The separation of concerns is an important principle
      of good software design and its most prominent representative probably
      is the Model-View-Controller pattern. MVC separates the business logic
      from the presentation by splitting up user interaction into three
      roles:</para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis>model</emphasis> is an object which contains
          data and business logic of a certain domain. It doesn't contain any
          information about the presentation of that data, but rather defines
          the behaviour. In the FLOW3 project we prefer a special kind of
          model, the <link
          ns5:href="http://martinfowler.com/eaaCatalog/domainModel.html">Domain
          Model</link>.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>view</emphasis> represents the display of the
          model on the web or another output channel. Views only display data,
          they don't build or modify it.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>controller</emphasis> reacts on user input,
          selects and manipulates the model as accordingly, selects a view and
          passes it the prepared model for rendering.</para>
        </listitem>
      </itemizedlist>

      <para>This diagram outlines the collaboration between model, view and
      controller:</para>

      <figure>
        <title>Model-View-Controller Pattern</title>

        <mediaobject>
          <imageobject>
            <imagedata contentdepth="100%"
                       fileref="MVCFramework_ModelViewController.png"
                       scalefit="1" width="100%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Other Patterns Used</title>

      <para>Design Patterns (and MVC is one of them) are not only great for
      solving reoccuring design problems in a structured manner - they also
      help you communicating software designs. The following patterns play an
      important role in FLOW3's MVC mechanism and might give you a better idea
      of the overall design:</para>

      <itemizedlist>
        <listitem>
          <para>Incoming requests are handled by a Request Handler which takes
          the role of a <link ns5:href="???">Front Controller</link>.</para>
        </listitem>

        <listitem>
          <para><link ns5:href="???">Template View</link> is the most commonly
          used pattern for views, but <link ns5:href="???">Transform
          Views</link> and <link ns5:href="???">Two-Step Views</link> are
          equally supported.</para>
        </listitem>

        <listitem>
          <para>The preferred type of model is the <link ns5:href="???">Domain
          Model</link>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Hello World!</title>

      <para>Let's start with an example before we go into greater detail of
      request handling and the internals of the MVC framework. The minimal
      approach is to create an Action Controller which just returns
      <quote>Hello World!</quote>. To begin with, we need to create some
      directories which contain the code of our FLOW3 package and eventually
      the controller class:</para>

      <literallayout>Packages/
  Demo/
    Classes/
      Controller/
        StandardController.php</literallayout>

      <para>The StandardController class looks as simple as this (leaving out
      the very recommended comments):</para>

      <example>
        <title>Hello World! controller</title>

        <programlisting language="PHP">namespace F3\Demo\Controller;

class StandardController extends \F3\FLOW3\MVC\Controller\ActionController {
   public function indexAction() {
      return "Hello World!";
   }
}</programlisting>
      </example>

      <para>Provided that the document root of your local server points to
      FLOW3's <filename>Public/</filename> directory, you will get the
      following output when calling the URI
      <uri>http://localhost/demo/</uri>:</para>

      <screen>Hello World!</screen>

      <para>Great, that was easy - but didn't we say that it's the view's
      responsibility to take care of the presentation? Let's create a simple
      PHP-based view for that purpose:</para>

      <literallayout>Packages/
  Demo/
    Classes/
      Controller/
        StandardController.php
      View/
        Standard/
          Index.php</literallayout>

      <para>The view's code is equally trivial:</para>

      <example>
        <title>Hello World! view</title>

        <programlisting language="php">namespace F3\Demo\View\Standard;

class Index extends \F3\FLOW3\MVC\View\AbstractView {
   public function render() {
      return "Hello World!";
   }
}</programlisting>
      </example>

      <para>Finally our action controller needs a little tweak to return the
      rendered view instead of shouting <quote>Hello World!</quote>
      itself:</para>

      <example>
        <title>Improved Hello World! controller</title>

        <programlisting language="php">namespace F3\Demo\Controller;

class StandardController extends \F3\FLOW3\MVC\Controller\ActionController {
   public function indexAction() {
      return $this-&gt;view-&gt;render();
   }
}</programlisting>
      </example>

      <para>Some notes about the view: Although a view class written in PHP is
      the most basic way to implement a view, it is not the most common way
      you'll take. In practice you'll want to use <package>Fluid</package>,
      FLOW3's powerful templating engine which allows you to write views in
      plain HTML and still have all the power like loops and conditions.
      </para>
    </section>

    <section>
      <title>Recommended File Structure</title>

      <para>As you have seen in the hello world example, conventions for the
      directory layout simplify your development a lot. There's no need to
      register controllers, actions or views if you follow our recommended
      file structure. These are the rules:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Controllers</emphasis> are located in their own
          directory <filename>Controller</filename> just below the
          <filename>Classes</filename> directory of your package. They can
          have arbitrary names while the
          <classname>StandardController</classname> has a special meaning: If
          the package was specified in the request but no controller, the
          <classname>StandardController</classname> will be used.</para>
        </listitem>

        <listitem>
          <para><emphasis>View</emphasis> classes are situated below a
          <filename>View</filename> directory. The classname of the view is a
          combination of the name of the controller and the name of the
          action.</para>
        </listitem>
      </itemizedlist>

      <para>This sample directory layout demonstrates the above rules:</para>

      <example>
        <title>Sample file structure</title>

        <literallayout>Packages/
  Demo/
    Classes/
      Controller/
        StandardController.php
        CustomerController.php
        OrderController.php
      View/
        Standard/
          Index.php
        Customer/
          Index.php
          List.php
          Details.php
        Order/
          List.php</literallayout>
      </example>

      <para>Adhering to these conventions has the advantage that the classname
      of the view for example is resolved automatically. However it is
      possible (and not really difficult) to deviate from this layout and have
      a completely different structure.</para>
    </section>

    <section>
      <title>From the URI to the view</title>

      <caution>
        <para>For the example URIs we assume that the web root directory of
        your local server points to FLOW3's <filename>public/</filename>
        directory. If that's not the case you have to extend the URI
        accordingly.</para>
      </caution>

      <para>FLOW3 provides a standard way of resolving the URI to your
      MVC-Objects.</para>

      <para>Say, you want to see the list of customers (based on the
      file-structure-example above). The URI to get the list would be:
      <uri>http://localhost/demo/customer/list.html</uri> or just
      <uri>http://localhost/demo/customer/list</uri>.</para>

      <para>This URI will be resolved into the package-name
      (<emphasis>Demo</emphasis>), controller-name
      (<emphasis>Customer</emphasis>), action-name(<emphasis>list</emphasis>)
      and format-name (<emphasis>html</emphasis> - which is the default
      format).</para>

      <para>Depending on that, the controller
      <classname>\F3\Demo\Controller\CustomerController</classname> (pattern:
      '<code>F3\@package\Controller\@controllerController'</code>) and its
      method <methodname>listAction()</methodname> will be used. The
      corresponding view is <classname>\F3\Demo\View\CustomerList</classname>
      (Pattern:
      <code>'F3\@package\View\@controller@action@format'</code>).</para>

      <para>By looking at the view pattern you easily see that you it's fairly
      easily to address a view which renders a different format, for example
      XML. All you need to do is creating a class called
      <classname>\F3\Demo\View\CustomerListXML</classname>. To see the output
      of this new view, just use the URI
      <uri>http://localhost/demo/customer/list.xml</uri>.</para>
    </section>
  </section>

  <section>
    <title>Request and Response</title>

    <para>No matter if a FLOW3 application runs in a web context or is
    launched from the command line, the basic workflow is always the same: The
    user request is analyzed and forwarded to an appropriate controller which
    decides on which actions to take and finally returns a response which is
    handed over to the user. This section highlights the flow and the
    collaborators in the request-response machinery.</para>

    <section>
      <title>Request Processing Overview</title>

      <para>A sequence diagram is worth a thousand words said my grandma, so
      let's take a look at the standard request-response workflow in
      FLOW3:</para>

      <figure>
        <title>Example of a Web Request-Response Workflow</title>

        <mediaobject>
          <imageobject>
            <imagedata contentdepth="100%"
                       fileref="MVCFramework_RequestResponseWorkflow.png"
                       scalefit="1" width="100%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>As you see, there are a lot of parts of the framework involved for
      answering a request - and the diagram doesn't even consider caching or
      forwarding of requests. But we didn't create this structure just for the
      fun of it - each object plays an important role as you'll see in the
      next sections.</para>
    </section>

    <section>
      <title>Request Handler</title>

      <para>The request handler takes the important task to handle and respond
      to a request. There exists exactly one request handler for each request
      type. By default web and command line requests are supported, but more
      specialized request handlers can be developed, too.</para>

      <para>Before one of the request handlers comes to play, the framework
      needs to determine which of them is the most suitable for the current
      request. The request handler resolver asks all of the registered request
      handlers to rate on a scale how well they can handle the current raw
      request. The resolver then chooses the request handler with the most
      points and passes over the control.</para>

      <para>Custom request handlers for special purposes just need to
      implement the
      <interfacename>\F3\FLOW3\MVC\RequestHandlerInterface</interfacename>.
      All classes implementing that interface are automatically registered and
      will be considered while resolving a suitable request handler.</para>
    </section>

    <section>
      <title>Request Builder</title>

      <para>When a request handler receives a raw request, it needs to build a
      request object which can be passed to the dispatcher and later to the
      controller. The request building delegated to a request builder which
      can build the required request type (ie. web, CLI etc.).</para>

      <para>The building process mainly consists of</para>

      <procedure>
        <step>
          <para>create a new request object</para>
        </step>

        <step>
          <para>set some request-type specific parameters (like the request
          URI for a web request)</para>
        </step>

        <step>
          <para>determine and set the responsible controller, action and
          action arguments</para>
        </step>
      </procedure>

      <para>Especially the last step is important and requires some more or
      less complex routing in case of web requests.</para>
    </section>

    <section>
      <title>Request Dispatcher</title>

      <para>The final task of the MVC framework consists in dispatching the
      request to the controller specified in the request object. Dispatching
      means that the request and response object is passed to the controller
      specified in the request object and after the controller did its job,
      control is returned to the request handler which eventually sends the
      response.</para>

      <para>The dispatch method itself is a loop which tries to invoke a
      controller until a flag in the request object indicates that the request
      has been dispatched. In most cases this loop has only one cycle: the
      action method specified in the request is called and the action
      controller automatically sets the <varname>dispatched</varname> flag
      which leads to exiting the dispatch loop. However, when the controller
      wants to forward or redirect the request to another controller or
      action, the respective information is written to the request object and
      the <varname>dispatched</varname> flag remains unset. Therefore the
      dispatcher calls the next controller which hopefully can finally process
      the request and exits the dispatch loop.</para>

      <para>The dispatcher comes with a safeguard which assures that the
      dispatching process does not end up in an endless loop.</para>
    </section>

    <section>
      <title>Request Types</title>

      <para>FLOW3 supports the most important request types out of the box.
      Additional request types can easily be implemented by implementing the
      <interfacename>\F3\FLOW3\MVC\RequestInterface</interfacename> or
      extending the <classname>\F3\FLOW3\MVC\Request</classname> class and
      registering a request handling which can handle the new request type
      (and takes care of building the request object). Here are the request
      types which come with the default FLOW3 distribution:</para>

      <section>
        <title>Web Request / Response</title>

        <para>Web requests are the most common request types. Additional to
        the common request functionality, this request type delivers
        information about the request method, request URI and the base
        URI.</para>
      </section>

      <section>
        <title>CLI Request / Response</title>

        <para>Requests from the command line are recognized by the used SAPI
        (Server Application Programming Interface).</para>
      </section>
    </section>
  </section>

  <section>
    <title>Controller</title>

    <para>The main responsibility of a controller is to process a request and
    deliver a meaningful response. The
    <interfacename>\F3\FLOW3\MVC\Controller\ControllerInterface</interfacename>
    therefore only contains two methods:</para>

    <programlisting>/**
 * Checks if the current request type is supported by the controller.
 *
 * @param \F3\FLOW3\MVC\RequestInterface $request The current request
 * @return boolean TRUE if this request type is supported, otherwise FALSE
 */
public function canProcessRequest(\F3\FLOW3\MVC\RequestInterface $request);

/**
 * Processes a general request. The result can be returned by altering the given response.
 *
 * @param \F3\FLOW3\MVC\RequestInterface $request The request object
 * @param \F3\FLOW3\MVC\ResponseInterface $response The response, modified by the controller
 * @return void
 * @throws \F3\FLOW3\MVC\Exception\UnsupportedRequestType if the controller doesn't support the current request type
 */
public function processRequest(\F3\FLOW3\MVC\RequestInterface $request, \F3\FLOW3\MVC\ResponseInterface $response);
</programlisting>

    <para>However, only few applications will implement the whole request
    processing logic themselves. Most of the time you'll be extending the
    Action Controller.</para>

    <section>
      <title>Action Controller</title>

      <para>The
      <classname>\F3\FLOW3\MVC\Controller\ActionController</classname>
      processes a request by calling action methods. Actions are the
      foundation of your application's workflow and logic. Which action is
      called is usually determined by the URI as you have already seen in the
      short hello world example.</para>

      <section>
        <title>Initialization Methods</title>

        <para>Before an action method is called, the view, validation and
        arguments are initialized. The following methods can be extended or
        overloaded to hook into this initialization process:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>initializedView()</methodname> is called in
            order to resolve, set and initialize a view which matches the
            current action.</para>
          </listitem>

          <listitem>
            <para><methodname>initializedAction()</methodname> is called after
            the view has been initialized and the automatic registration of
            arguments is done. At that point, the argument's values are still
            empty and have not been validated.</para>
          </listitem>

          <listitem>
            <para><methodname>initializedFooAction()</methodname> where
            <methodname>Foo</methodname> is the name of the action, is called
            only before an action of that name is called.</para>
          </listitem>
        </itemizedlist>

        <para>Action arguments are usually registered automatically (see
        below). If you wish to register additional arguments manually, you may
        do that in one of the <methodname>initialize*Action()</methodname>
        methods.</para>
      </section>

      <section>
        <title>Configuration</title>

        <para>The settings of the package containing your controller are
        automatically injected into the action controller and can be accessed
        through the <varname>$this-&gt;settings</varname> variable. Please
        note that this variable contains all settings of the package as an
        array, not only settings specific to your controller.</para>

        <para>You should not modify the settings array because any information
        you'd add would be lost anyway and is invisible to other parts of your
        application.</para>
      </section>

      <section>
        <title>Supported Request Types</title>

        <para>The action controller generally supports any kind of request,
        which means that theoretically you need only one controller for web
        and CLI requests. In practice you might want to structure your
        application so that a controller is responsable for only one request
        type. If that is the case, you can define the supported request types
        by setting the <property>supportedRequestTypes</property> property of
        your class:</para>

        <example>
          <title>Defining the supported request types</title>

          <programlisting>/**
 * My web-specific controller
 *
 * @package Demo
 * @subpackage Controller
 */
class StandardController extends \F3\FLOW3\MVC\Controller\ActionController {

   /**
    * @var array
    */
   protected $supportedRequestTypes = array('F3\FLOW3\MVC\Web\Request');

</programlisting>
        </example>
      </section>

      <section>
        <title>Arguments</title>

        <para>An action usually needs some more information about what it's
        supposed to do. This information comes in form of GET or POST
        arguments in case of a web request or via command line options if
        we're dealing with a CLI request. Because there are even more ways to
        pass information to an action and because this information needs
        special care to assure a secure application, these arguments are
        abstracted by FLOW3 in form of controller arguments.</para>

        <para>The basic rule in FLOW3 is: an action method only gets those
        arguments it asked for which have always values which are allowed for
        the declared data type. Therefore arguments need to be registered and
        it is not possible to access PHP's superglobals
        <varname>$_GET</varname> and <varname>$_POST</varname>
        directly.</para>

        <para>Fortunately argument registration is very easy in FLOW3. It's
        just a matter declaring the arguments in your action method
        signature:</para>

        <example>
          <title>Declaring arguments in an action method</title>

          <programlisting>/**
 * An example action method
 *
 * @param string $emailAddress Some email address
 * @param string $streetName Some street name
 * @param F3\Foo\Customer $customer A customer object
 * @return void
 */
public function exampleAction($emailAddress, $streetName, \F3\Foo\Customer $customer) {
   
}
</programlisting>
        </example>

        <para>FLOW3 will automatically register the arguments
        <parameter>$emailAddress</parameter>,
        <parameter>$streetName</parameter> and
        <parameter>$customer</parameter>. Their expected data types are
        <classname>Text</classname>, <classname>Text</classname> and
        <classname>\F3\Foo\customer</classname> respectively.</para>

        <para>In essence this means that if you send a GET parameter
        <parameter>emailAddress</parameter> with your request, it will end up
        in <parameter>$emailAddress</parameter> if it is a valid
        <classname>Text</classname> (which means: no HTML, no JavaScript, no
        danger). Even the <parameter>$customer</parameter> argument will
        contain a real <classname>Customer</classname> object if enough
        information has been sent with the request.</para>
      </section>

      <section>
        <title>Argument Validation</title>

        <para>All arguments passed to the action methods will automatically
        validated through their base validation rules defined in the
        respective models. Additional validation rules can be defined by using
        the <varname>@validate</varname> annotation. The syntax is similar to
        a regulare <varname>@validate</varname> declaration with the addition
        that the argument name must be specified:</para>

        <example>
          <title>Additional validation rules in an action method</title>

          <programlisting>/**
 * An example action method
 *
 * @param string $emailAddress Some email address
 * @param string $streetName Some street name
 * @param F3\Foo\Customer $customer A customer object
 * @return void
 * @validate $emailAddress EmailAddress
 * @validate $streeName AlphaNumeric, StringLength(minimum = 5, maximum = 100)
 * @validate $customer F3\Foo\PlatinumCustomerValidator
 */
public function exampleAction($emailAddress, $streetName, \F3\Foo\Customer $customer) {
   
}
</programlisting>
        </example>
      </section>

      <section>
        <title>Action Methods</title>

        <para>$this-&gt;indexActionMethodName</para>

        <para></para>
      </section>

      <section>
        <title>Action View</title>

        <para>- $this-&gt;initializeView = TRUE | FALSE</para>

        <para>Setting $this-&gt;viewObjectName to a view object name overrides
        the automatic resolving of the view name. Can be used for definining a
        standard view, for example \F3\Fluid\View\TemplateView.</para>
      </section>
    </section>

    <section>
      <title>Other Controllers</title>

      <section>
        <title>Abstract Controller</title>

        <para></para>
      </section>

      <section>
        <title>Request Handling Controller</title>

        <para></para>
      </section>

      <section>
        <title>Standard Controller</title>

        <para></para>
      </section>

      <section>
        <title>Not Found Controller</title>

        <para>The
        <classname>F3\FLOW3\MVC\Controller\NotFoundController</classname> is
        used whenever no other controller could be resolved which would match
        the current request. It displays a generic "404 Page Not Found"
        message.</para>

        <para>It is possible to define your own custom controller which is
        used in these cases. Just specify the object name in the FLOW3
        settings.</para>
      </section>
    </section>
  </section>

  <section>
    <title>View</title>

    <para></para>

    <section>
      <title>Template View</title>

      <para></para>
    </section>

    <section>
      <title>Special Views</title>

      <section>
        <title>Standard View</title>

        <para></para>
      </section>

      <section>
        <title>Empty View</title>

        <para></para>
      </section>
    </section>
  </section>

  <section>
    <title>Helpers</title>

    <para></para>
  </section>

  <section>
    <title>Model</title>

    <para></para>
  </section>

  <section>
    <title>Routing</title>

    <para></para>
  </section>

  <section>
    <title>CLI request handling</title>

    <para>FLOW3's CLI request handling offers a comfortable and flexible way
    of calling code from the command line:</para>

    <para><command>php index.php [<replaceable>command</replaceable>]
    [<replaceable>options</replaceable>] [--]
    [<replaceable>arguments</replaceable>]</command></para>

    <para><replaceable>command</replaceable>,
    <replaceable>options</replaceable> and
    <replaceable>arguments</replaceable> are optional, with varying results.
    The command structure follows what is commonly accpeted on unixoid systems
    for CLI programs:<variablelist>
        <varlistentry>
          <term>command</term>

          <listitem>
            <para>If not given, the default controller of the FLOW3 package is
            used and it's index action is called. While this is an allowed
            call, it hardly makes sense (other than checking if FLOW basically
            works). If command is given then it is defined as
            <emphasis><replaceable>package</replaceable>
            [[<replaceable>sub1..N</replaceable>]
            <replaceable>controller</replaceable>
            <replaceable>action</replaceable>]</emphasis></para>

            <para>First part is always the package. If only the package is
            given, it's StandardController's index action is called.</para>

            <para>If at least three command parts are given, the last two
            sepcify controller and action. Anything in between specifys a sub
            package structure.<example>
                <title>Some FLOW3 CLI command specifications</title>

                <para><literal>testing cli run</literal> would call the "run"
                action of the "cli" controller in the "Testing" package</para>

                <para><literal>typo3cr admin setup foo</literal> would call
                the "setup" controller's "foo" action in the subpackage
                "admin" of the package "TYPO3CR"</para>
              </example></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>options</term>

          <listitem>
            <para>Options are either short- or long-style. The first option
            detected ends collecting command parts. Here are some
            examples:<example>
                <title>Giving options to FLOW3 CLI requests</title>

                <para><literal>-o -f=value --a-long-option --with-spaces="is
                possible" --input file1 -o=file2 --event-this =
                works</literal></para>
              </example></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>arguments</term>

          <listitem>
            <para>Arguments can follow and will be available to the called
            controller in the request object. To distinguish between
            <replaceable>command</replaceable> and
            <replaceable>arguments</replaceable> in cases where no
            <replaceable>options</replaceable> are given the seperator
            <literal>--</literal> must be used.</para>
          </listitem>
        </varlistentry>
      </variablelist></para>

    <example>
      <title>Some FLOW3 CLI commands</title>

      <para>Calling the TYPO3CR setup:</para>

      <para><code>php index.php typo3cr admin setup setup
      --dsn=sqlite:/tmp/typo3cr.db --indexlocation=/tmp/lucene/</code></para>

      <para>Running FLOW3 unit tests:</para>

      <para><code>php index.php testing cli run --package-key=FLOW3
      --output-directory=./</code></para>

      <para>Rendering the FLOW3 documentation to HTML:</para>

      <para><code>php index.php doctools render render -p FLOW3 -o
      flow3-manual/</code></para>
    </example>
  </section>
</chapter>
