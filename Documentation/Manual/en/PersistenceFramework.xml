<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Persistence Framework</title>

  <section>
    <title>Introductory Example</title>

    <para>Let's look at the following example as an introduction to how FLOW3
    handles persistence. We have a domain model of a Blog, consisting of Blog,
    Post, Comment and Tag objects:<figure>
        <title>The objects of the Blog domain model</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="PersistenceFramework_BlogDomainModel.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Connections between those objects are built by simple references in
    PHP, as a look at the <methodname>addPost()</methodname> method of the
    <classname>Blog</classname> class shows:<example>
        <title>The Blog's addPost() method</title>

        <para><programlisting>/**
 * @param F3\Blog\Domain\Post $post
 * @return void
 */
public function addPost(F3\Blog\Domain\Post $post) {
    $this-&gt;posts[] = $post;
}</programlisting></para>
      </example></para>

    <para>The same principles are applied to the rest of the classes,
    resulting in an object tree of a blog object holding several posts, those
    in turn having references to their associated comments and tags. But now
    we need to make sure the Blog and the data in it are still available the
    next time we need them. In the good old days of programming you might have
    added some ugly database calls all over the system at this point. In the
    currently widespread practice of loving Active Record you'd still add
    save() methods to all or most of your objects. But can it be even
    easier?</para>

    <para>To access an object you need to hold some reference to it. You can
    get that reference by creating an object or by following some reference to
    it from some object you already have. This leaves you at a point where you
    need to find that "first object". This is done by using a Repository. A
    Repository is the librarian of your system, knowing about all the objects
    it manages. In our model the Blog is the entry point to our object tree,
    so we will add a BlogRepository, allowing us to find Blogs by the criteria
    we need.</para>

    <para>Now, before we can find a Blog, we need to create and save one. What
    we do is create the object (using FLOW3's object factory) and add it to
    the BlogRepository. This will automagically persist your Blog and you can
    retrieve it again later. No save() call needed. Oh, and the posts, commens
    and tags in your Blog are persisted as well, of course.</para>

    <para>For all that magic to work as expected, you need to give some hints.
    This doesn't mean you need to write tons of XML, a few annotations in your
    code are enough:<example>
        <title>Persistence-related annotations in the Blog class</title>

        <para><programlisting>/**
 * A Blog object
 *
 * @package Blog
 * @entity
 */
class Blog {

    /**
     * @var string
     */
    protected $title;

    /**
     * @var array
     */
    protected $posts = array();

  ...

}</programlisting></para>
      </example>The first annotation to note is the
    <emphasis>@entity</emphasis> annotation, which tells the persistence
    framework it needs to persist Blog instances if they have been added to a
    Repository. In the Blog class we have some member variables, they are
    persisted as well by default. The persistence framework knows their types
    by looking at the <emphasis>@var</emphasis> annotation you use anyway when
    documenting your code (you do document your code, right?). In case of the
    $posts array the persistence framework persists the objects held in that
    array as independent objects.</para>

    <para>Let's conclude by taking a look at the BlogRepository code:<example>
        <title>Code of a simple BlogRepository</title>

        <programlisting>/**
 * A BlogRepository
 *
 * @package Blog
 */
class BlogRepository extends \F3\FLOW3\Persistence\Repository {

    /**
     * Finds Blogs with a matching name.
     *
     * @param string $name
     * @return array
     */
    public function findByName($name) {
        $query = $this-&gt;createQuery();
        return $query-&gt;matching($query-&gt;equals('name', $name))-&gt;execute();
    }
}</programlisting>
      </example>As you can see we get away with very little code by simply
    extending the FLOW3-provided repository class. Nice, eh? If you like to do
    things the hard way you can get away with implementing
    <interfacename>\F3\FLOW3\Persistence\RepositoryInterface</interfacename>
    yourself.</para>
  </section>

  <section>
    <title>On the priciples of DDD</title>

    <para>From Evans, the rules we need to enforce include:</para>

    <itemizedlist>
      <listitem>
        <para>The root Entity has global identity and is ultimately
        responsible for checking invariants.</para>
      </listitem>

      <listitem>
        <para>Root Entities have global identity. Entities inside the boundary
        have local identity, unique only within the Aggregate.</para>
      </listitem>

      <listitem>
        <para>Nothing outside the Aggregate boundary can hold a reference to
        anything inside, except to the root Entity. The root Entity can hand
        references to the internal Entities to other objects, but they can
        only use them transiently (within a single method or block).</para>
      </listitem>

      <listitem>
        <para>Only Aggregate Roots can be obtained directly with database
        queries. Everything else must be done through traversal.</para>
      </listitem>

      <listitem>
        <para>Objects within the Aggregate can hold references to other
        Aggregate roots.</para>
      </listitem>

      <listitem>
        <para>A delete operation must remove everything within the Aggregate
        boundary all at once.</para>
      </listitem>

      <listitem>
        <para>When a change to any object within the Aggregate boundary is
        committed, all invariants of the whole Aggregate must be
        satisfied.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Persistence-related annotations</title>

    <para>The following table lists all annotations used by the persistence
    framework with their name, scope and meaning:<table>
        <title>Persistence-related code annotations</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Annotation</entry>

              <entry>Scope</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>@entity</entry>

              <entry>Class</entry>

              <entry>Declares a class as an Entity.</entry>
            </row>

            <row>
              <entry>@valueobject</entry>

              <entry>Class</entry>

              <entry>Declares a class as a Value Object, allowing the
              persistence framework to reuse an existing object if one
              exists.</entry>
            </row>

            <row>
              <entry>@var</entry>

              <entry>Variable</entry>

              <entry>Is used to detect the type a variable has.</entry>
            </row>

            <row>
              <entry>@transient</entry>

              <entry>Variable</entry>

              <entry>Makes the persistence framework ignore the variable.
              Neither will it's value be persisted, nor will it be touched
              during reconstitution.</entry>
            </row>

            <row>
              <entry>@identifier</entry>

              <entry>Variable</entry>

              <entry>Marks the variable as being the object identifier. This
              makes the persistence backend use the value of this variable as
              identifier for the internal representation of the object.
              <emphasis>You must make sure your identifier is unique,
              preferable use an UUID.</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </section>

  <section>
    <title>Querying the storage backend</title>

    <para>As we saw in the introductory example there is a query mechanism
    available that allows for relatively easy fetching of objects through the
    persistence framework. You ask for instances of a specific class that
    match certain filters and get back an array of those reconstituted
    objects. Here is a diagram of the internal process:<figure>
        <title>Object querying and reconstitution process</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="PersistenceFramework_QueryProcess.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>For the developer the complexity is hidden between the query's
    <methodname>execute()</methodname> method and the array of objects being
    returned.</para>
  </section>
</section>
