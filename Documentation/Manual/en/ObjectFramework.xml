<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
			xmlns:xl="http://www.w3.org/1999/xlink"
			xmlns:xi="http://www.w3.org/2001/XInclude"
			xmlns:xhtml="http://www.w3.org/1999/xhtml"
			xmlns:svg="http://www.w3.org/2000/svg"
			xmlns:ns="http://docbook.org/ns/docbook"
			xmlns:mathml="http://www.w3.org/1998/Math/MathML">
<title>Object Framework</title>

<para>All objects are controlled centrally by the Object Framework. It
implements the <firstterm>Inversion of Control</firstterm>
(<acronym>IoC</acronym>) principle and provides some additional features
such as a caching mechanism for objects. Because all packages are built on
this foundation it is important to understand the general idea of objects
and the container. This chapter introduces the basic principles behind the
Object Manager.</para>

<tip>
	<para>A very good start to understand the idea of Inversion of Control and
	<firstterm>Dependency Injection</firstterm> is reading <link
	xl:href="http://martinfowler.com/articles/injection.html">Martin Fowler's
	article</link> on the topic.</para>
</tip>

<section>
	<title>If you remember only one thing</title>

	<para>If the IoC principle, Dependency Injection and objects are all new
	to you, you'll surely need some time getting used to these new approaches.
	But don't worry - you can even ignore the idea behind it and still produce
	acceptable code. If you remember only one thing about objects, please let
	it be this section. There are a few rules you have to follow, even if you
	don't use the more advanced features.</para>

	<para><orderedlist>
		<listitem>
			<para><emphasis>Avoid the <function>new</function>
			operator!</emphasis></para>

			<para>The instantiation of classes must be handled by the Object
			Framework. Therefore if you have to instantiate a class or need an
			existing instance of a class, you'll have to call an API function
			instead of using the <function>new</function> operator:</para>

			<example>
				<title>Don't use the new operator</title>

				<programlisting language="php">   // Avoid this:
$myFreshObject = new \F3\MyPackage\MyClassName;</programlisting>
			</example>

			<example>
				<title>Ask the Object Factory</title>

				<programlisting language="php">namespace F3\MyPackage;

/**
 * A sample class
 */
class SomeClass {

	/**
	 * @var \F3\FLOW3\Object\FactoryInterface
	 */
	protected $objectFactory;

	/**
	 * Constructs this sample class
	 *
	 * @param \F3\FLOW3\Object\FactoryInterface $objectFactory A reference to the object factory
	 */
	public function __construct(\F3\FLOW3\Object\FactoryInterface $objectFactory) {
		$this-&gt;objectFactory = $objectFactory;
	}

	/**
	 * Just some method
	 *
	 * @return void
	 */
	public function someFunction() {
		$myFreshObject = $this-&gt;objectFactory-&gt;create('F3\MyPackage\MyClassName');
	}
}</programlisting>
			</example>

			<para>In the above example you ask the Object Factory for a fresh
			instance of <classname>\F3\MyPackage\MyClassName</classname>. In
			order to get the Object Factory instance, just add a parameter to
			your class constructor as seen in the example - you will
			automatically get a reference <emphasis>injected</emphasis>.</para>
		</listitem>

		<listitem>
			<para><emphasis>Singletons and Prototypes</emphasis></para>

			<para>A <link
			xl:href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton</link>
			is the name of a Design Pattern which ensures that only one instance
			of a class exists at a time. In PHP you can implement the Singleton
			pattern by creating a function (usually called
			<function>getInstance()</function>), which returns a unique instance
			of your class. Although this way of implementing the Singleton will
			possibly not conflict with the Object Manager, it is counter
			productive to the integrity of the system and might raise problems
			with unit testing (sometimes the Singleton is referred to as a
			<emphasis>Anti Pattern</emphasis>).</para>

			<para>The Object Factory can only be used for creating fresh
			instances (scope: prototype). However, all objects in FLOW3 follow,
			if not configured differently, the Singleton pattern and therefore
			can only be instantiated once. Instead of calling the Object
			Factory, you use Dependency Injection for retrieving unique
			instances of Singleton-type classes. One kind of Dependency
			Injection is called <firstterm>constructor injection</firstterm> and
			is demonstrated in the above example: The
			<classname>ObjectFactory</classname> itself is a Singleton.</para>

			<para>If your own classes should rather be handled as prototypes,
			you will have to configure the scope of it by adding some
			annotation:</para>

			<example>
				<title>Sample scope annotation</title>

				<programlisting language="php">/**
 * This is my great class.
 *
 * @scope prototype
 */
class SomeClass {

}</programlisting>
			</example>

			<para>Now it's possible to create fresh instances of
			<classname>SomeClass</classname> by calling the
			<methodname>create()</methodname> method of the
			<classname>ObjectFactory</classname>.</para>
		</listitem>
		</orderedlist></para>
</section>

<section>
	<title>Component objects and containers</title>

	<para>The idea to segment software into reusable components which can be
	easily composed into a whole, is as old as software development itself. It
	is a tempting idea to just combine ready-made components instead of
	sorting out code from earlier projects which can hopefully be reused.
	Although the initial vision of mass-produced software with prefabricated
	components did not become reality, software componentry is undoubtedly a
	good thing, something you want your application framework to have support
	for.</para>

	<para>Since version 3.5, TYPO3 allows anyone to extend the built-in
	functionality by developing their own extensions. This plugin concept has
	proven to be very powerful and led to thousands of publicly available
	extensions contributed by our community. While a plugin based system is
	usually based on a monolithic core the plugins can hook onto, a component
	based system is only composed of components itself. FLOW3, the foundation
	of TYPO3 version 5, is a component based framework giving you lots of
	opportunities to cleanly extend and modify virtually any part of the
	system.</para>

	<section>
		<title>Components</title>

		<para>All PHP classes which are managed by the Object Manager are in
		fact component objects.<tip>
			<para>All classes which are found in the
			<filename>Classes</filename> directory of a package are
			automatically registered as component objects (See chapter <olink
			targetdoc="package-manager">Package Manager</olink>)</para>
		</tip></para>

		<para>In contrast to plain, standalone classes which are probably only
		used in a project or two, the development of reusable components
		requires the author to pay more attention on proper documentation,
		testing and encapsulation. If a component is well designed, it doesn't
		expose the internal functions and properties of the class but only
		allows access through a well-thought API. By following this
		blackbox-principle, it is much easier to modify the internal behaviour
		of an object at a later time, because it is always known which functions
		can be used from outside.</para>
	</section>

	<section>
		<title>Container</title>

		<para>In simple, self-contained applications, creating objects is as
		simple as using the <function>new</function> operator. However, as the
		program gets more complex, a developer is confronted with solving
		dependencies to other objects, make classes configurable (maybe through
		a factory method) and finally assure a certain scope for the object
		(such as <firstterm>Singleton</firstterm> or
		<firstterm>Prototype</firstterm>). <personname>
		<firstname>Howard</firstname> <othername>Lewis</othername>
		<surname>Ship</surname> </personname>explained this circumstances nicely
		in <link
		xl:href="http://tapestryjava.blogspot.com/2004/08/dependency-injection-mirror-of-garbage.html">his
		blog</link> (quite some time ago):</para>

		<blockquote>
		<para>Garbage collection is the last stage of an object's life cycle,
		but there's just as much going on at the start of the object's life
		cycle. That's why object frameworks and dependency injection
		containers (such as HiveMind, Spring, Picocontainer and Avalon) are so
		important.</para>

		<para>[...] Once you start thinking in terms of large numbers of
		objects, and a whole lot of just-in-time object creation and
		configuration, the question of <emphasis>how</emphasis> to create a
		new object doesn't change (that's what <function>new</function> is
		for) ... but the questions <emphasis>when</emphasis> and
		<emphasis>who</emphasis> become difficult to tackle. Especially when
		the <emphasis>when</emphasis> is very dynamic, due to just-in-time
		instantiation, and the <emphasis>who</emphasis> is unknown, because
		there are so many places a particular object may be used.</para>
		</blockquote>

		<para>We as PHP developers don't have to care about garbage collection
		and we surely wouldn't like to be responsible for it either. However,
		<emphasis>building</emphasis> objects can be even more complex than
		<emphasis>destructing</emphasis> them. Therefore the FLOW3 framework
		manages the whole lifecycle of objects for you. The Object Manager is a
		so called <firstterm>Lightweight Container</firstterm> taking care of
		object building and dependency resolution. We'll discover shortly why
		dependency injection makes such a difference to your application
		design.</para>
	</section>

	<section>
		<title>Object Framework API</title>

		<para>The Object Framework provides a lean API for registering,
		configuring and retrieving instances of objects. Some of the methods
		provided are exclusively used within the <package>FLOW3</package>
		package or in unit tests and should possibly not be used elsewhere. By
		offering Dependency Injection, the Object Framework helps you to avoid
		creating rigid interdependencies between objects. It allows for writing
		code which is hardly or even not at all aware of the framework it is
		working in.</para>

		<para>Although Dependency Injection is what you should strive for, it
		might happen that you need to retrieve object instances directly.
		Instead of using PHP's <function>new</function> operator, you must ask
		the Object Factory for the fresh instance of an object.</para>

		<para>First, you need an instance of the Object Factory itself and as
		you have seen in the shortcut example before, one way of getting it is
		adding a new parameter to your class constructor method:</para>

		<programlisting language="php">public function __construct(\F3\FLOW3\Object\FactoryInterface $objectFactory) {
	$this-&gt;objectFactory = $objectFactory;
}</programlisting>

		<para>To explicitly create an instance of an object use the
		<function>create()</function> method:</para>

		<programlisting language="php">$myObjectInstance = $objectFactory-&gt;create('F3\MyPackage\MyClassName');</programlisting>

		<note>
		<para>When specifying class names as string arguments never use a
		leading backslash. As is the case with plain PHP, class names in
		strings are always considered to be fully qualified in terms of
		namespacing.</para>
		</note>

		<para>It is possible to pass arguments to the constructor of the object
		class just by adding them to the <function>create()</function>
		call:</para>

		<programlisting language="php">$myObjectInstance = $objectFactory-&gt;create('F3\MyPackage\MyClassName', 'first argument', 'second argument');</programlisting>
	</section>

	<section>
		<title>Manually Retrieving Singleton Instances</title>

		<para>Although Dependency Injection is what you should strive for, it
		might happen that you need to retrieve object instances directly. The
		<classname>ObjectManager</classname> provides methods for retrieving
		object instances for these rare situations.</para>

		<para>First, you need an instance of the
		<classname>ObjectManager</classname> itself and as you have seen in the
		shortcut example before, one way of getting it is adding a new parameter
		to your class constructor method (constructor injection):</para>

		<programlisting language="php">public function __construct(\F3\FLOW3\Object\ManagerInterface $objectManager) {
	$this-&gt;objectManager = $objectManager;
}</programlisting>

		<para>To explicitly retrieve an object instance use the
		<function>getObject()</function> method:</para>

		<programlisting language="php">$myObjectInstance = $objectManager-&gt;getObject('F3\MyPackage\MyClassName');</programlisting>

		<para>Like with the <classname>ObjectFactory</classname>'s
		<methodname>create</methodname> method, it is possible to pass arguments
		to the constructor of the object class just by adding them to the
		<function>getObject()</function> call. However passing arguments to a
		Singleton object makes only sense on the first call when the instance is
		actually created. On all consecutive calls the arguments are just
		ignored.</para>
	</section>

	<section>
		<title>Object names and types</title>

		<para>By default, the name of an object is identical to the PHP class
		which implements the object's functions. A class called
		<classname>\F3\MyPackage\MyImplementation</classname> will be
		automatically available as an object with the exact same name. Every
		part of the system which asks for an object instance with a certain name
		will therefore - by default - get an instance of the class of that name.
		It is possible to replace the original implementation of a object by
		another one. In that case the class name of the new implementation will
		naturally differ from the object name which stays the same at all
		times.</para>

		<para>If the object name is the same as the name of a PHP interface, it
		is often referred to as a <emphasis>object type</emphasis>. An interface
		called <interfacename>\F3\MyPackage\MyInterface</interfacename> will be
		available as an object name as long as there exists at least one class
		implemententing that interface.</para>

		<programlisting language="php">$otherObjectInstance = $objectFactory-&gt;create('F3\SomePackage\SomeInterfaceName');</programlisting>
	</section>
</section>

<section>
	<title>Object dependencies</title>

	<para>The intention to base an application on a combination of packages
	and objects is to force a clean separation of domains which are realized
	by dedicated objects. The less each object knows about the internals of
	another object, the easier it is to modify or replace one of them, which
	in turn makes the whole system flexible. In a perfect world, each of the
	objects could be reused in a variety of contexts, for example
	independently from the <package>TYPO3</package> package and maybe even
	outside the FLOW3 framework.</para>

	<section>
		<title>Dependency Injection</title>

		<para>An important prerequisite for resuable code is already met by
		encouraging encapsulation through the objects approach. However, the
		objects are still aware of their environment as they need to actively
		collaborate with other objects and the framework itself: An
		authentication object will need a logger for logging intrusion attempts
		and the code of a shop system hopefully consists of more than just one
		class. Whenever an object refers to another directly, it adds more
		complexity and removes flexibility by opening new interdependencies. It
		is very difficult or even impossible to reuse such hardwired
		classes.</para>

		<para>By introducing <firstterm>Dependency Injection</firstterm>, these
		interdependencies are minimized by inverting the control over resolving
		the dependencies: Instead of asking for the instance of an object
		actively, the depending object just gets one
		<emphasis>injected</emphasis> by the Object Manager. This methodology is
		also referred to as the "<link
		xl:href="http://en.wikipedia.org/wiki/Hollywood_Principle">Hollywood
		Principle</link>": <quote>Don't call us, we'll call you.</quote>. It
		helps in the development of code with loose coupling and high cohesion –
		or in short: It makes you a better programmer.</para>

		<para>In the context of the previous example it means that the
		authentication object announces that it needs a logger which implements
		a certain PHP interface (eg. the
		<interfacename>\F3\FLOW3\Log\LoggerInterface</interfacename>). The
		object itself has no control over what kind of logger (simple file
		logger, sms-logger, ...) it finally gets and it doesn't have to care
		about it anyway as long as it matches the expected API. As soon as the
		authentication object is instantiated, the object manager will resolve
		these dependencies, prepare an instance of a logger and inject it to the
		authentication object.</para>

		<tip>
		<para><link xl:href="http://www.ddj.com/dept/java/184405016">An
		article</link> by <personname><firstname>Jonathan</firstname>
		<surname>Amsterdam</surname></personname> discusses the difference
		between creating an object and requesting one (ie. using
		<function>new</function> versus using dependency injection). It
		demonstrates why <function>new</function> should be considered as a
		low-level tool and outlines issues with polymorphism. He doesn't
		mention dependency injection though ...</para>
		</tip>

		<para>Dependencies on other objects can be declared in the objects
		configuration (see section about configuring objects) or they can be
		solved automatically (so called autowiring). Generally there are two
		modes of dependency injection supported by FLOW3: <firstterm>Constructor
		Injection</firstterm> and <firstterm>Setter
		Injection</firstterm>.</para>

		<section>
		<title>Constructor Injection</title>

		<para>With constructor injection, the dependencies are passed as
		constructor arguments to the depending object while it is
		instantiated. Here is an example of the authentication object which
		depends on a logger object:</para>

		<example>
			<title>A simple example for Constructor Injection</title>

			<programlisting language="php">public class LDAPAuthentication {

	protected $logger;

	public function __construct(\F3\FLOW3\Log\LoggerInterface $logger) {
		$this-&gt;logger = $logger;
	}

	public function authenticate($credentials) {
		$this-&gt;logger-&gt;log('tried to authenticate');
	}
}</programlisting>
		</example>

		<para>So far there's nothing special about this class, it just makes
		sure that an instance of a class implementing the
		<interfacename>\F3\FLOW3\Log\LoggerInterface</interfacename> is passed
		to the constructor. However, this is already a quite flexible approach
		because the type of logger can be determined from outside by just
		passing one or the another implementation to the constructor.</para>

		<para>Now the FLOW3 Object Manager does some magic: By a mechanism
		called <firstterm>Autowiring</firstterm> all dependencies which were
		declared in a constructor will be injected automagically if the
		constructor argument provides a type definition (ie.
		<classname>\F3\FLOW3\Log\LoggerInterface</classname> in the above
		example). Autowiring is activated by default (but can be switched
		off), therefore all you have to do is to write your constructor
		method.</para>

		<para>The Object Factory can also be configured manually to inject a
		certain object or object type. You'll have to do that either if you
		want to switch off autowiring or want to specify a configuration which
		differs from would be done automatically.</para>

		<example>
			<title>Objects.yaml file for Constructor Injection</title>

			<programlisting language="yaml">F3_Authentication_LDAPAuthentication:
constructorArguments:
	1: { object: F3\FLOW3\Log\ASpecialLogger }</programlisting>
		</example>

		<para>The three lines above define that an object instance of
		<interfacename>\F3\FLOW3\Log\ASpecialLogger</interfacename> must be
		passed to the first argument of the constructor when an instance of
		the object <classname>F3\Authentication\LDAPAuthentication</classname>
		is created. Mind that in the configuration file the class name is
		written with underscores!</para>
		</section>

		<section>
		<title>Setter Injection</title>

		<para>With setter injection, the dependencies are passed by calling
		<firstterm>setter methods</firstterm> of the depending object right
		after it has been instantiated. Here is an example of the
		authentication object which depends on a logger object - this time
		with setter injection:</para>

		<example>
			<title>A simple example for Setter Injection</title>

			<programlisting language="php">public class LDAPAuthentication {

	protected $someLogger;

	public function authenticate($credentials) {
		$this-&gt;logger-&gt;log('tried to authenticate');
	}

	public function setSomeLogger(\F3\FLOW3\Log\LoggerInterface $someLogger) {
		$this-&gt;someLogger = $someLogger;
	}
}</programlisting>
		</example>

		<para>Analog to the constructor injection example, a logger object is
		injected into the authentication object. In this case, however, the
		injection only takes place after the class has been instantiated and a
		possible constructor method has been called. The neccessary
		configuration for the above example looks like this:</para>

		<example>
			<title>Objects.yaml file for Setter Injection</title>

			<programlisting language="php">F3_Authentication_LDAPAuthentication:
properties:
	someLogger: { object: F3\FLOW3\Log\LoggerInterface }</programlisting>
		</example>

		<para>Unlike constructor injection, setter injection like in the above
		example does not offer the autowiring feature. All depedencies have to
		be declared explicitly in the object configuration. To save you from
		writing large configuration files, FLOW3 supports a second type of
		setter methods: By convention all methods whose name start with
		"inject" are considered as setters for setter injection. For those
		methods no further configuration is necessary, dependencies will be
		autowired (if autowiring is not disabled):</para>

		<example>
			<title>The preferred way of Setter Injection, using an inject
			method</title>

			<programlisting language="php">public class LDAPAuthentication {

	protected $someLogger;

	public function authenticate($credentials) {
		$this-&gt;logger-&gt;log('tried to authenticate');
	}

	public function injectSomeLogger(\F3\FLOW3\Log\LoggerInterface $someLogger) {
		$this-&gt;someLogger = $someLogger;
	}
}</programlisting>
		</example>

		<para>Note the new method name
		<methodname>injectSomeLogger</methodname> - for the above example no
		further configuration is required (but possible). Using
		<methodname>inject*</methodname> methods is the preferred way for
		setter injection in FLOW3.</para>

		<note>
			<para>If both, a <methodname>set*</methodname> and a
			<methodname>inject*</methodname> method exist for the same property,
			the <methodname>inject*</methodname> method has precendence.</para>
		</note>

		<sidebar>
			<title>Constructor- or Setter Injection?</title>

			<para>The natural question which arises at this point is
			<quote>Should I use Constructor- or Setter Injection?</quote>. There
			is no answer across-the-board – it mainly depends on the situation
			and your preferences. The authors of the Java-based <link
			xl:href="http://www.springframework.org">Spring Framework</link> for
			example prefer Setter Injection for its flexibility. The more
			puristic developers of <link
			xl:href="www.picocontainer.org">PicoContainer</link> strongly plead
			for using Constructor Injection for its cleaner approach. If you
			have the choice, we suggest taking the latter, for the very same
			reasons the PicoContainer team gives:</para>

			<itemizedlist>
				<listitem>
				<para>Constructor Injection makes a stronger dependency
				contract</para>
				</listitem>

				<listitem>
				<para>It enforces a determinate state of the depending object:
				In the Setter Injection example above, the logger is only
				available after the constructor has been called already</para>
				</listitem>
			</itemizedlist>

			<para>However, there might be situations in which constructor
			injection is not possible or even cumbersome:</para>

			<itemizedlist>
				<listitem>
				<para>If an object has many dependencies and maybe even many
				optional depedencies, setter injection might be a better
				solution.</para>
				</listitem>

				<listitem>
				<para>Subclasses are not always in control over the arguments
				passed to the constructor or might even be incapable of
				overriding the original constructor (FLOW3's action controller
				is such a case). Then setter injection is your only chance to
				get dependencies injected.</para>
				</listitem>

				<listitem>
				<para>Setter injection can be helpful to avoid circular
				dependencies between objects.</para>
				</listitem>
			</itemizedlist>
		</sidebar>
		</section>
	</section>

	<section>
		<title>Required and optional dependencies</title>

		<para>All dependencies defined in a constructor are, by its nature,
		required. If a dependency can't be solved by autowiring or by
		configuration, FLOW3's object builder will throw an exception.</para>

		<para>Also <emphasis>autowired setter-injected dependencies</emphasis>
		are, by default, required. There is a way to declare a setter-injected
		dependency as optional without the need to configure the dependency in a
		<filename>Objects</filename> configuration file. If an optional
		dependency can't be solved, it just won't be injected and it is the
		developer's responsability to test for the availability of the desired
		object. FLOW3 uses the @optional annotation for this purpose:</para>

		<example>
		<title>Marking a setter-injected dependency as optional</title>

		<programlisting language="php">public class LDAPAuthentication {

	/**
	 * @var \F3\FLOW3\Log\LoggerInterface
	 */
	protected $someLogger;

	/**
	 * Show-off-method
	 *
	 * @param mixed $credentials
	 * @return void
	 */
	public function authenticate($credentials) {
		$this-&gt;logger-&gt;log('tried to authenticate');
	}

	/**
	 * Injects a logger
	 *
	 * @param \F3\FLOW3\Log\LoggerInterface $someLogger A logger which is used for logging LDAP authentication events
	 * @return void
	 * @author Robert Lemke &lt;robert@typo3.org&gt;
	 * @optional
	 */
	public function injectSomeLogger(\F3\FLOW3\Log\LoggerInterface $someLogger) {
		$this-&gt;someLogger = $someLogger;
	}
}</programlisting>
		</example>

		<para>Due to the @optional annotation, the injection of a logger is now
		no longer required. If the object builder can't autowire a logger for
		this injection method, it will now no longer throw an exception.</para>
	</section>

	<section>
		<title>Dependency resolution</title>

		<para>The dependencies between objects are only resolved during the
		instantiation process. Whenever a new instance of an object class needs
		to be created, the object configuration is checked for possible
		dependencies. If there is any, the required objects are built and only
		if all dependencies could be resolved, the object class is finally
		instantiated and the dependency injection takes place.</para>

		<section>
		<title>Circular dependencies</title>

		<para>During the resolution of dependencies it might happen that
		circular dependencies occur. If an object A requires an object B to be
		injected to its constructor and then again object B requires a object
		A likewise passed as a constructor argument, none of the two classes
		can be instantiated due to the mutual dependency. Although it is
		technically possible (albeit quite complex) to solve this type of
		reference, FLOW3's policy is not to allow circular dependencies at
		all. As a workaround you can use Setter Injection instead of
		Constructor Injection for either one or both of the objects causing
		the trouble.</para>
		</section>
	</section>
</section>

<section>
	<title>Configuring objects</title>

	<para>The behaviour of objects significantly depends on their
	configuration. During the initialization process all classes found in the
	various <filename>Classes/</filename> directories are registered as
	objects and an initial configuration is prepared. In a second step, other
	configuration sources are queried for additional configuration options.
	Definitions found at these sources are added to the base configuration in
	the following order:</para>

	<orderedlist>
		<listitem>
		<para>If they exist, the
		<filename><replaceable>PackageName</replaceable>/Configuration/Objects.*</filename>
		will be included.</para>
		</listitem>

		<listitem>
		<para>Additional configuration defined in the global
		<filename>Configuration/</filename> directory is applied.</para>
		</listitem>
	</orderedlist>

	<para>Currently there are three important situations in which you want to
	configure objects:</para>

	<itemizedlist>
		<listitem>
		<para>Override one object implementation with another</para>
		</listitem>

		<listitem>
		<para>Set the active implementation for an object type</para>
		</listitem>

		<listitem>
		<para>Explicitly define dependencies to other objects</para>
		</listitem>
	</itemizedlist>

	<section>
		<title>Configuration sources</title>

		<para>As already mentioned, the configuration for each object is
		compiled from different sources. The <filename>Objects.yaml</filename>
		file is the recommended format and is therefore used in most of the
		examples. However, the names of the configuration options and their
		possible values are identical to all configuration sources.</para>

		<section>
		<title>Objects.yaml</title>

		<para>If a file named <filename>Objects.yaml</filename> exists in the
		<filename>Configuration</filename> directory of a package, it will be
		included during the configuration process (ie. before the first object
		class is instantiated!). The YAML file should stick to FLOW3's general
		rules for YAML-based configuration.</para>

		<para>The following code adds the same configuration as in the
		Constructor Injection example which will be used in the next
		sections:</para>

		<example>
			<title>Sample Objects.yaml file</title>

			<programlisting language="yaml">#                                                                        #
# Object Configuration for the Authentication package                 #
# (this package doesn't really exist, and even if so, the configuration  #
# would probably be different)                                           #
#                                                                        #

# @package Authentication
# @version $Id: Objects.yaml 123 2008-01-01 12:00:00Z robert $

F3_Authentication_LDAPAuthentication:
constructorArguments:
	1: { object: F3\FLOW3\Log\LoggerInterface }

F3_Authentication_LDAPAuthentication: constructorArguments: 2: object: F3\LDAP\LDAPServerInterface

F3_Authentication_LDAPAuthentication:
constructorArguments:
	3: 'cn=John Smith,ou=TYPO3 Development,o=TYPO3 Association,c=CH'</programlisting>
		</example>
		</section>

		<section>
		<title>Objects.php</title>

		<para>As an alternative to YAML, it is possible to write configuration
		files in plain PHP. However, the PHP file should stick to FLOW3's
		general rules for PHP-based configuration.</para>

		<para>The following code again adds the same configuration as in the
		Constructor Injection example:</para>

		<example>
			<title>Sample Objects.php file</title>

			<programlisting language="php">&lt;?php
declare(ENCODING = 'utf-8');

/*                                                                        *
 * Object Configuration for the Authentication package                 *
 * (this package doesn't really exist, and even if so, the configuration  *
 * would probably be different)                                           *
 *                                                                        */

/**
 * @package Authentication
 * @version $Id: Objects.php 123 2008-01-01 12:00:00Z robert $
 */

$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[1]-&gt;object = 'F3\FLOW3\Log\LoggerInterface';
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[2]-&gt;object = 'F3\LDAP\LDAPServerInterface';
$c-&gt;F3_Authentication_LDAPAuthentication-&gt;constructorArguments[3] = 'cn=John Smith,ou=TYPO3 Development,o=TYPO3 Association,c=CH';

?&gt;</programlisting>
		</example>

		<caution>
			<para>Only use these files for configuration, for example don't
			register autoloader methods in the <filename>Objects.php</filename>
			as this code must be invoked in an earlier stage. The
			<filename>Package.php</filename> is the right place for registering
			autoloaders.</para>
		</caution>
		</section>

		<section>
		<title>Annotations</title>

		<para>A very convenient way to configure certain attributes of objects
		are annotations. You write down the configuration directly where it
		takes effect: in the class file. However, this way of configuring
		objects is not really flexible, as it is hard coded. That's why only
		those options can be set through annotations which are part of the
		class design and won't change afterwards. Currently
		<literal>scope</literal> is the only supported annotation.</para>

		<para>It's up to you defining the scope in the class directly or doing
		it in a <filename>Objects</filename> configuration file – both have
		the same effect. We recommend using annotations in this case, as the
		scope usually is a design decision which is very unlikely to be
		changed.</para>

		<example>
			<title>Sample scope annotation</title>

			<programlisting language="php">/**
 * This is my great class.
 *
 * @scope prototype
 */
class SomeClass {

}</programlisting>
		</example>
		</section>
	</section>

	<section>
		<title>Overriding objects</title>

		<para>One advantage of objectry is the ability to replace objects by
		others without any bad impact on those parts depending on them. A
		prerequisite for replaceable objects is that their classes implement a
		common <link
		xl:href="http://www.php.net/manual/en/language.oop5.interfaces.php">interface</link>
		which defines the public API of the original object. Other objects which
		implement the same interface can then act as a true replacement for the
		original object without the need to change code anywhere in the system.
		If this requirement is met, the only necessary step to replace the
		original implementation with a substitute is to alter the object
		configuration and set the class name to the new implementation.</para>

		<para>To illustrate this circumstance, consider the following
		classes:</para>

		<example>
		<title>A simple Greeter class</title>

		<programlisting language="php">namespace F3\MyPackage;

class Greeter {
	public function sayHelloTo($name) {
		echo('Hello ' . $name);
	}
}</programlisting>
		</example>

		<para>During initialization above class will automatically be registered
		as the object <classname>F3\MyPackage\Greeter</classname> and is
		available to other objects. In the code of another object you might find
		these lines:</para>

		<example>
		<title>Code using the object F3_MyPackage_Greeter</title>

		<programlisting language="php">   // Use setter injection for fetching an instance of the \F3\MyPackage\Greeter object:
public function injectGreeter(\F3\MyPackage\Greeter $greeter) {
	$this-&gt;greeter = $greeter;
}

public function someAction() {
	$greeter-&gt;sayHelloTo('Heike');
}</programlisting>
		</example>

		<para>Great, that looks all fine and dandy but what if we want to use
		the much better object
		<classname>\F3\OtherPackage\GreeterWithCompliments</classname>? Well,
		you just configure the object
		<classname>\F3\MyPackage\Greeter</classname> to use a different
		class:</para>

		<example>
		<title>Objects.yaml file for object replacement</title>

		<programlisting language="php">   # Change the name of the class which represents the object "F3\MyPackage\Greeter":
F3_MyPackage_Greeter: className: 'F3\OtherPackage\GreeterWithCompliments'</programlisting>
		</example>

		<para>Now all objects who ask for a traditional greeter will get the
		more polite version. However, there comes a sour note with the above
		example: We can't be sure that the
		<classname>GreeterWithCompliments</classname> class really provides the
		necessary <function>sayHello()</function> method. The solution is to let
		both implementations implement the same interface:</para>

		<example>
		<title>The Greeter object type</title>

		<programlisting>namespace F3\MyPackage;

interface GreeterInterface {
	public function sayHelloTo($name);
}

class Greeter implements \F3\MyPackage\GreeterInterface {
	public function sayHelloTo($name) {
		echo('Hello ' . $name);
	}
}

namespace F3\OtherPackage;

class GreeterWithCompliments implements \F3\MyPackage\GreeterInterface{
	public function sayHelloTo($name) {
		echo('Hello ' . $name . '! You look so great!');
	}
}</programlisting>
		</example>

		<para>Instead of referring to the original implementation directly we
		can now refer to the interface. In this case we call the object name a
		<emphasis>object type</emphasis> because it contains the name of a PHP
		interface.</para>

		<example>
		<title>Code using the object type
		F3\MyPackage\GreeterInterface</title>

		<programlisting>   // Use setter injection for fetching an instance of the \F3\MyPackage\Greeter object:
public function injectGreeter(\F3\MyPackage\GreeterInterface $greeter) {
	$this-&gt;greeter = $greeter;
}

public function someAction() {
	$greeter-&gt;sayHelloTo('Heike');
}</programlisting>
		</example>

		<para>Finally we have to set which implementation of the
		<interfacename>F3\MyPackage\GreeterInterface</interfacename> should be
		active:</para>

		<example>
		<title>Objects.yaml file for object type definition</title>

		<para><programlisting>F3_MyPackage_GreeterInterface: className: 'F3\OtherPackage\GreeterWithCompliments'</programlisting></para>
		</example>
	</section>

	<section>
		<title>Object types</title>

		<para>Any interface found in the <filename>Classes/</filename> directory
		will equally be registered as an object if at least one class within the
		same package was found that implements this interface. The first class
		found in the package which implements the interface is considered to be
		the default implementation and the object's <option>className</option>
		option is set accordingly. Of course it is still possible that the class
		name is defined explicitly in the package's <filename>Objects</filename>
		configuration file or any other configuration source. This is especially
		important if more than one implementing class exists.</para>
	</section>

	<section>
		<title>Injecting properties and constructor arguments</title>

		<para>As mentioned earlier, the Object Factory allows for injection of
		straight values or objects (ie. dependencies) either by passing them
		as constructor arguments during instantiation of the object class or by
		calling a setter method which sets the wished property accordingly. The
		following sections demonstrate how to pass values and define
		dependencies to other objects.</para>

		<section>
		<title>Straight values and objects</title>

		<para>Regardless of what injection type is used, there are two kinds
		of value which can be injected:</para>

		<itemizedlist>
			<listitem>
				<para><emphasis>Straight values</emphasis> are static values of a
				simple type. They can be strings, integers, booleans, array or
				even custom objects (ie. objects which are not handled by the
				Object Framework) and are passed on as they are.</para>
			</listitem>

			<listitem>
				<para><emphasis>References</emphasis> are names of objects (or
				object types) which represent dependencies to other objects.
				Dependencies are resolved and an instance of the object is passed
				along.</para>
			</listitem>
		</itemizedlist>
		</section>

		<section>
		<title>Constructor Injection</title>

		<para>The following class and the related
		<filename>Objects.php</filename> file demonstrate the syntax for the
		definition of Constructor Injection:</para>

		<example>
			<title>Sample class for Constructor Injection</title>

			<para><programlisting language="php">public class LDAPAuthentication {

	protected $logger;
	protected $LDAPServer;
	protected $distinguishedName = '';

	public function __construct(\F3\FLOW3\Log\LoggerInterface $logger, \F3\LDAP\LDAPServerInterface $LDAPServer, $distinguishedName) {
		$this-&gt;logger = $logger;
		$this-&gt;LDAPServer = $LDAPServer;
		$this-&gt;distinguishedName = $distinguishedName;
	}

	public function authenticate(\F3\Authentication\CredentialsInterface $credentials) {
		$this-&gt;LDAPServer-&gt;doSomeMagic($this-&gt;distinguishedName);
		$this-&gt;logger-&gt;log('tried to authenticate');
	}
}</programlisting></para>
		</example>

		<example>
			<title>Sample configuration for Constructor Injection</title>

			<programlisting language="yaml">F3_Authentication_LDAPAuthentication:
constructorArguments:

	# Inject two object references as the first two arguments:
	1: { object: 'F3\FLOW3\Log\LoggerInterface' }
	2: { object: 'F3\LDAP\LDAPServerInterface' }

	# Inject a straight value as the third argument:
	3: 'cn=John Smith,ou=TYPO3 Development,o=TYPO3 Association,c=CH'</programlisting>
		</example>

		<note>
			<para>It is usually not necessary to configure injection of
			objects explicitly. It is much more convent to just declare the
			type of the constructor arguments (like
			<interfacename>F3\FLOW3\Log\LoggerInterface</interfacename> and
			<interfacename>F3\LDAP\LDAPServerInterface in the above example) and
			let the Autowiring feature configure and resolve the dependencies
			for you.</interfacename></para>
		</note>
		</section>

		<section>
		<title>Setter Injection</title>

		<para>The following class and the related
		<filename>Objects.yaml</filename> file demonstrate the syntax for the
		definition of Setter Injection:</para>

		<example>
			<title>Sample class for Setter Injection</title>

			<para><programlisting language="php">public class LDAPAuthentication {

	protected $logger;
	protected $LDAPServer;
	protected $distinguishedName = '';

	public function authenticate(\F3\Authentication\CredentialsInterface $credentials) {
		$this-&gt;LDAPServer-&gt;doSomeMagic($this-&gt;distinguishedName);
		$this-&gt;logger-&gt;log('tried to authenticate');
	}

	public function injectLogger(\F3\FLOW3\Log\LoggerInterface $logger) {
		$this-&gt;logger = $logger;
	}

	public function injectLDAPServer(\F3\LDAP\LDAPServerInterface $LDAPServer) {
		$this-&gt;LDAPServer = $LDAPServer;
	}

	public function setDistinguishedName($distinguishedName) {
		$this-&gt;distinguishedName = $distinguishedName;
	}
}</programlisting></para>
		</example>

		<example>
			<title>Sample configuration for Setter Injection</title>

			<programlisting language="php">F3_Authentication_LDAPAuthentication:
properties:

	# Inject two object references:
	logger:     { object: 'F3\FLOW3\Log\LoggerInterface' }
	LDAPServer: { object: 'F3\LDAP\LDAPServerInterface' }

	# Inject a straight value:
	distinguishedName: 'cn=John Smith,ou=TYPO3 Development,o=TYPO3 Association,c=CH'</programlisting>
		</example>

		<para>As you can see, it is important that a setter method with the
		same name as the property, preceded by "inject" or "set"
		exists.</para>
		</section>
	</section>
</section>

<section>
	<title>Instantiating objects</title>

	<para>In order to accomplish all the tasks connected with Dependency
	Injection and other advanced features, FLOW3 must take full control over
	the instantiation of the object classes. Usually it's sufficient to know
	that you have to either create a new instance with the
	<function>create</function> method of the Object Factory or get them
	injected by the Object Manager. From the object's point of view, a few
	options may be set to take influence on the instantiation of its class.
	This section explains these configuration options and finally outlines the
	instantiation process as a whole.</para>

	<section>
		<title>Scopes</title>

		<para>The objects created by the Object Factory all exist in a certain
		<firstterm>scope</firstterm>. By default, an instance of a object class
		is unique which makes sure that the exact same object is returned
		whenever the Object Factory is asked for a specific object. This default
		scope is called <firstterm>Singleton</firstterm>. Of course other scopes
		are supported as well:</para>

		<table>
		<title>Supported scopes</title>

		<tgroup cols="2">
			<thead>
				<row>
				<entry align="center">Scope</entry>

				<entry align="center">Description</entry>
				</row>
			</thead>

			<tbody>
				<row>
				<entry>singleton (default)</entry>

				<entry>The object instance is unique during one request - each
				injection by the Object Manager or explicit call of
				<function>getObject</function> returns the same instance. A
				request can be an HTTP request or a run initiated from the
				command line.</entry>
				</row>

				<row>
				<entry>prototype</entry>

				<entry>The object instance is not unique - each call of the
				Object Factory's <function>create</function> method returns a
				fresh instance.</entry>
				</row>

				<row>
				<entry>session <remark>Not yet implemented</remark></entry>

				<entry>The object instance is unique during the whole user
				session - each injection or <function>getObject</function> call
				returns the same instance.</entry>
				</row>
			</tbody>
		</tgroup>
		</table>

		<para>A great feature of the Object Framework is that objects don't have
		to implement their own mechanism for administrating their scope - it
		only has to be configured. The following example contains configurations
		for three objects, all living in a different scope:</para>

		<example>
		<title>Sample Objects.php with different scopes</title>

		<para><programlisting language="php">$c-&gt;F3_MyPackage_ASingletonClass-&gt;scope = \F3\FLOW3\Object\Configuration::SCOPE_SINGLETON;
$c-&gt;F3_MyPackage_APrototypeClass-&gt;scope = \F3\FLOW3\Object\Configuration::SCOPE_PROTOTYPE;
$c-&gt;F3_MyPackage_ASessionClass-&gt;scope = \F3\FLOW3\Object\Configuration::SCOPE_SESSION;</programlisting></para>
		</example>

		<note>
		<para>Unlike in the above example, the recommended way to define the
		scope of an object is the <property>@scope</property>
		annotation.</para>
		</note>
	</section>

	<section>
		<title>Passing constructor arguments</title>

		<para>In most cases an object class will live in the Singleton scope and
		at most requires a few dependencies passed to its constructor. However,
		there are times when it becomes necessary to pass dynamic values as
		constructor arguments, especially when the object represents an entity
		and its instances are not unique (Prototype scope). Consider the
		following classes:</para>

		<example>
		<title>A simple addressbook</title>

		<programlisting language="php">namespace F3\Address;

class Adressbook {

	protected $addresses = array();

	public __construct(\F3\iCal\iCalConnectorInterface $iCalConnector) {
		...
	}

	public addAddress(\F3\Address\Address $address) {
		$this-&gt;addresses[] = $address;
	}

}

class Address {

	public __construct($street, $zip, $town, $country) {
		...
	}
}</programlisting>
		</example>

		<para>This is admittedly not the fanciest implementation of an address
		book, but it should demonstrate two things:</para>

		<itemizedlist>
		<listitem>
			<para>The class <classname>\F3\Address\Addressbook</classname> is
			supposed to be a Singleton and obviously depends on a third object
			type <classname>\F3\iCal\iCalConnectorInterface</classname> which is
			possibly solved by Dependency Injection.</para>
		</listitem>

		<listitem>
			<para>The class <classname>\F3\Address\Adress</classname> represents
			the address entity and its instances must not be unique - we surely
			want more than one address. The Address object also expects a few
			parameters passed to its constructor.</para>
		</listitem>
		</itemizedlist>

		<para>The following code demonstrates how this address book can be used
		and constructor arguments are passed to the Address entity:</para>

		<example>
		<title>Passing constructor arguments</title>

		<programlisting>   # Explicitly fetch a unique instance of the addressbook (but better use Dependency Injection ...):
$myAddressbook = $objectManager-&gt;getObject('F3\Address\Addressbook');

	# Create two new addresses and add them to the addressbook:
$newAddress = $objectFactory-&gt;create('F3\Address\Address', 'Tryggevældevej', '2720', 'København', 'DK');
$myAddresbook-&gt;addAddress($newAddress);

$newAddress = $objectFactory-&gt;create('F3\Address\Address', 'An den Brodbänken', '21335', 'Lüneburg', 'DE');
$myAddresbook-&gt;addAddress($newAddress);</programlisting>
		</example>
	</section>

	<section>
		<title>Autowiring</title>

		<para>Injecting dependencies to a constructor function is a common task.
		Because FLOW3 can detect the type of dependencies a constructor needs,
		it automatically configures the object to assert that the necessary
		objects are injected. This automation is called
		<firstterm>autowiring</firstterm> and is enabled by default for every
		object. To repeat our favourite example, imagine that your object class
		needs some kind of logger. All you need to do in order to get one is
		writing the following constructor:</para>

		<example>
		<title>An autowired logger</title>

		<programlisting language="PHP">public function __construct(\F3\FLOW3\Log\LoggerInterface $logger) {
	$logger-&gt;log("Hooray");
}</programlisting>
		</example>

		<para>The constructor of the above example will get an instance of the
		object of type
		<interfacename>\F3\FLOW3\Log\LoggerInterface</interfacename> injected
		and can use it for further operations.</para>

		<para>If, for some reason, you need to disable autowiring support, you
		can do so by setting an option in your object configuration:</para>

		<example>
		<title>Turning off autowiring support in Objects.yaml</title>

		<programlisting>F3_MyPackage_MyObject:
autoWiringMode: off;</programlisting>
		</example>
	</section>

	<section>
		<title>Lifecycle methods</title>

		<para>The lifecycle of an object goes through different stages. It boils
		down to the following order:</para>

		<orderedlist>
		<listitem>
			<para>Solve dependencies for constructor injection</para>
		</listitem>

		<listitem>
			<para>Create an instance of the object class</para>
		</listitem>

		<listitem>
			<para>Solve and inject dependencies for setter injection</para>
		</listitem>

		<listitem>
			<para>Live a happy object-life and solve exciting tasks</para>
		</listitem>

		<listitem>
			<para>Dispose the object instance</para>
		</listitem>
		</orderedlist>

		<para>Your object might want to take some action after certain of the
		above steps. Whenever one of the following methods exists in the object
		class, it will be invoked after the related lifecycle step:</para>

		<orderedlist>
		<listitem>
			<para>No action after this step</para>
		</listitem>

		<listitem>
			<para>During instantiation the function
			<function>__construct()</function> is called (by PHP itself),
			dependencies are passed to the constructor arguments</para>
		</listitem>

		<listitem>
			<para>After all dependencies have been injected (through
			constructor- or setter injection) the object's initialization method
			is called. The name of this method is configurable (see below) and
			it is called regardless of whether any dependencies have been
			injected or not</para>
		</listitem>

		<listitem>
			<para>During the life of an object no special lifecycle methods are
			called</para>
		</listitem>

		<listitem>
			<para>On disposal, the function <function>__destruct()</function> is
			called (by PHP itself)</para>
		</listitem>
		</orderedlist>

		<para>As you can see from the above list, there is only one special
		method which is provided by PHP's own means and that is the
		initialization method. Here's a simple example:</para>

		<example>
		<title>A object class with an initialization method</title>

		<programlisting>class MyClass {

	protected $logger;

	public function __construct(\F3\FLOW3\Log\LoggerInterface $logger) {
		$this-&gt;logger = $logger;
	}

	public function intializeObject() {
		$this-&gt;logger-&gt;log('MyClass has been initialized.');
	}
}</programlisting>
		</example>

		<para>The above example will just work out of the box without any
		further configuration. However, if you don't have control over the name
		of your initialization method (maybe, because you are integrating legacy
		code), you can configure the name of the method in the object
		configuration:</para>

		<example>
		<title>Objects.yaml configuration of the initialization method</title>

		<programlisting>F3_MyPackage_MyClass:
lifecycleInitializationMethod: myInitialize</programlisting>
		</example>
	</section>
</section>
</section>
