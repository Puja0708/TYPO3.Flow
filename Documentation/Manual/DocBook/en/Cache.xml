<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="flow3.cacheframework"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:ns52="http://www.w3.org/1998/Math/MathML"
         xmlns:ns5="http://www.w3.org/1999/xlink"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Cache Framework</title>

  <para>FLOW3 offers a caching framework to cache data. The system offers a
  wide variety of options and storage solutions for different caching needs.
  Each cache can be configured individually and can implement its own specific
  storage strategy.</para>

  <para>If configured correctly the caching framework can help to speed up
  installations, especially in heavy load scenarios. This can be done by
  moving all caches to a dedicated cache server with specialized cache systems
  like the Redis key-value store (a.k.a. NoSQL database), or shrinking the
  needed storage space by enabling compression of data.</para>

  <section>
    <title>Introduction</title>

    <para>The caching framework can handle multiple caches with different
    configurations. A single cache consists of any number of cache entries. A
    single cache entry is defined by these parts:<variablelist>
        <varlistentry>
          <term>identifier</term>

          <listitem>
            <para>A string as unique identifier within this cache. Used to
            store and retrieve entries.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>data</term>

          <listitem>
            <para>The data to be cached.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>lifetime</term>

          <listitem>
            <para>A lifetime in seconds of this cache entry. The entry can not
            be retrieved from cache if lifetime expired.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>tags</term>

          <listitem>
            <para>Additional tags (an array of strings) assigned to the entry.
            Used to remove specific cache entries.</para>
          </listitem>
        </varlistentry>
      </variablelist></para>

    <para>The difference between identifier and tags is hard to understand at
    first glance, it is illustrated with an example.</para>

    <section>
      <title>About the identifier</title>

      <para>The identifier used to store ("set") and retrieve ("get") entries
      from the cache holds all information to differentiate entries from each
      other. For performance reasons, it should be quick to calculate. Suppose
      there is an resource-intensive extension added as a plugin on two
      different pages. The calculated content depends on the page on which it
      is inserted and if a user is logged in or not. So, the plugin creates at
      maximum four different content outputs, which can be cached in four
      different cache entries:<itemizedlist>
          <listitem>
            <para>page 1, no user logged in</para>
          </listitem>

          <listitem>
            <para>page 1, a user is logged in</para>
          </listitem>

          <listitem>
            <para>page 2, no user logged in</para>
          </listitem>

          <listitem>
            <para>page 2, a user is logged in</para>
          </listitem>
        </itemizedlist>To differentiate all entries from each other, the
      identifier is build from the page id where the plugin is located,
      combined with the information whether a user is logged in. These are
      concatenated and hashed (with <methodname>sha1()</methodname>, for
      example). In PHP this could look like this: <programlisting
      language="php">$identifier = sha1((string)$this-&gt;getName() . (string)$this-&gt;isUserLoggedIn());</programlisting></para>

      <para>When the plugin is accessed, the identifier is calculated early in
      the program flow. Next, the plugin looks up for a cache entry with this
      identifier. If there is such an entry, the plugin can return the cached
      content, else it calculates the content and stores a new cache entry
      with this identifier. In general the identifier is constructed from all
      dependencies which specify an unique set of data. The identifier should
      be based on information which already exist in the system at the point
      of its calculation. In the above scenario the page id and whether or not
      a user is logged in are already determined during the frontend bootstrap
      and can be retrieved from the system quickly.</para>
    </section>

    <section>
      <title>About tags</title>

      <para>Tags are used to drop specific cache entries if the information an
      entry is constructed from changes. Suppose the above plugin displays
      content based on different news entries. If one news entry is changed in
      the backend, all cache entries which are compiled from this news row
      must be dropped to ensure that the frontend renders the plugin content
      again and does not deliver old content on the next frontend call. If for
      example the plugin uses news number one and two on one page, and news
      one on another page, the according cache entries should be tagged with
      these tags:<itemizedlist>
          <listitem>
            <para>page 1, tags news_1, news_2</para>
          </listitem>

          <listitem>
            <para>page 2, tag news_1</para>
          </listitem>
        </itemizedlist>If entry two is changed, a simple backend logic could
      be created, which drops all cache entries tagged with "news_2", in this
      case the first entry would be invalidated while the second entry still
      exists in the cache after the operation. While there is always exactly
      one identifier for each cache entry, an arbitrary number of tags can be
      assigned to an entry and one specific tag can be assigned to mulitple
      cache entries. All tags a cache entry has are given to the cache when
      the entry is stored (set).</para>
    </section>

    <section>
      <title>System architecture</title>

      <para>The caching framework architecture is based on these
      classes:<variablelist>
          <varlistentry>
            <term><classname>TYPO3\FLOW3\Cache\CacheFactory</classname></term>

            <listitem>
              <para>Factory class to instantiate caches.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><classname>TYPO3\FLOW3\Cache\CacheManager</classname></term>

            <listitem>
              <para>Returns the cache frontend of a specific cache. Implements
              methods to handle cache instances.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><interfacename>TYPO3\FLOW3\Cache\Frontend\FrontendInterface</interfacename></term>

            <listitem>
              <para>Interface to handle cache entries of a specific cache.
              Different frontends exist to handle different data types.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><interfacename>TYPO3\FLOW3\Cache\Backend\BackendInterface</interfacename></term>

            <listitem>
              <para>Interface for different storage strategies. A set of
              implementations exist with different characteristics.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>In your code you usually rely on dependency injection to have your
      caches injected. Thus you deal mainly with the API defined in the
      <interfacename>FrontendInterface</interfacename>.</para>
    </section>
  </section>

  <section>
    <title>Configuration</title>

    <para>The cache framework is configured in the usual FLOW3 way through
    YAML files. The most important is <filename>Caches.yaml</filename>,
    although you may of course use <filename>Objects.yaml</filename> to
    further configre the way your caches are used. Caches are given a (unique)
    name and have three keys in their configuration:<variablelist>
        <varlistentry>
          <term>frontend</term>

          <listitem>
            <para>The frontend to use for the cache.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>backend</term>

          <listitem>
            <para>The backend to use for the cache.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>backendOptions</term>

          <listitem>
            <para>The backend options to use.</para>
          </listitem>
        </varlistentry>
      </variablelist></para>

    <para>As an example for such a configuration take a look at the default
    that is inherited for any cache unless overridden:<example>
        <title>Default cache settings</title>

        <programlisting>##
# Default cache configuration
#
# If no frontend, backend or options are specified for a cache, these values
# will be taken to create the cache.
Default:
  frontend: TYPO3\FLOW3\Cache\Frontend\VariableFrontend
  backend: TYPO3\FLOW3\Cache\Backend\FileBackend
  backendOptions:
    defaultLifetime: 0
</programlisting>
      </example></para>

    <para>Some backends have mandatory as well as optional parameters (which
    are documented below). If not all mandatory options are defined, the
    backend will throw an exception on the first access. To override options
    for a cache, simply set them in <filename>Caches.yaml</filename> in your
    global or package <filename>Configuration</filename> directory.<example>
        <title>Configuration to use RedisBackend for FooCache</title>

        <programlisting>FooCache:
  backend: TYPO3\FLOW3\Cache\Backend\RedisBackend
  backendOptions:
    database: 3
</programlisting>
      </example></para>
  </section>

  <section>
    <title>Cache frontends</title>

    <section>
      <title>Frontend API</title>

      <para>All frontends must implement the API defined in the interface
      <interfacename>TYPO3\FLOW3\Cache\Frontend\FrontendInterface</interfacename>.
      All cache operations must be done with these methods.<variablelist>
          <varlistentry>
            <term><methodname>getIdentifier()</methodname></term>

            <listitem>
              <para>Returns the cache identifier.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>getBackend()</methodname></term>

            <listitem>
              <para>Returns the backend instance of this cache. It is seldom
              needed in usual code.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>set()</methodname></term>

            <listitem>
              <para>Sets/overwrites an entry in the cache.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>get()</methodname></term>

            <listitem>
              <para>Return the cache entry for the given identifier.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>has()</methodname></term>

            <listitem>
              <para>Check for existance of a cache entry.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>remove()</methodname></term>

            <listitem>
              <para>Remove the entry for the given identifier from the
              cache.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>flushByTag()</methodname></term>

            <listitem>
              <para>Flush all cache entries which are tagged with the given
              tag.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>flushByTags()</methodname></term>

            <listitem>
              <para>Remove all cache entries which are tagged with one of the
              given tags.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>collectGarbage()</methodname></term>

            <listitem>
              <para>Call the garbage collection method of the backend. This is
              important for backends which are unable to do this
              internally.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>isValidIdentifier()</methodname></term>

            <listitem>
              <para>Checks if a given identifier is valid.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><methodname>isValidTag()</methodname></term>

            <listitem>
              <para>Checks if a given tag is valid.</para>
            </listitem>
          </varlistentry>
        </variablelist>Check the API documentation for details on these
      methods.</para>
    </section>

    <section>
      <title>Available frontends</title>

      <para>Currenly three different frontends are implemented, the main
      difference is the data types which can be stored using a specific
      frontend.<variablelist>
          <varlistentry>
            <term><classname>TYPO3\FLOW3\Cache\Frontend\StringFrontend</classname></term>

            <listitem>
              <para>The string frontend accepts strings as data to be
              cached.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><classname>TYPO3\FLOW3\Cache\Frontend\VariableFrontend</classname></term>

            <listitem>
              <para>Strings, arrays and objects are accepted by this frontend.
              Data is serialized before it is given to the backend. The
              igbinary serializer is used transparently (if available in the
              system) which speeds up the serialization and unserialization
              and reduces data size. The variable frontend is the most
              frequently used frontend and handles the widest range of data
              types. While it can also handle string data, the string frontend
              should be used in this case to avoid the additional
              serialization done by the variable frontend.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><classname>TYPO3\FLOW3\Cache\Frontend\PhpFrontend</classname></term>

            <listitem>
              <para>This is a special frontend to cache PHP files. It extends
              the string frontend with the method
              <methodname>requireOnce</methodname>() and allows PHP files to
              be <function>require()</function>'d if a cache entry exists.
              This can be used to cache and speed up loading of calculated PHP
              code and becomes handy if a lot of reflection and dynamic PHP
              class construction is done. A backend to be used with the PHP
              frontend must implement the
              <interfacename>TYPO3\FLOW3\Cache\Backend\PhpCapableBackendInterface</interfacename>.
              Currently the file backend is the only backend which fulfills
              this requirement.</para>

              <note>
                <para>The PHP frontend can only be used to cache PHP files, it
                does not work with strings, arrays or objects.</para>
              </note>
            </listitem>
          </varlistentry>
        </variablelist></para>
    </section>
  </section>

  <section>
    <title>Cache backends</title>

    <para>Currently already a number of different storage backends exists.
    They have different characteristics and can be used for different caching
    needs. The best backend depends on given server setup and hardware, as
    well as cache type and usage. A backend should be chosen wisely, a wrong
    decision could slow down an installation in the end.</para>

    <section>
      <title>Common options</title>

      <para><table>
          <title>Common cache backend options</title>

          <tgroup cols="5">
            <colspec/>

            <colspec colwidth="4*"/>

            <colspec/>

            <colspec/>

            <colspec/>

            <thead>
              <row>
                <entry>Option</entry>

                <entry>Description</entry>

                <entry>Mandatory</entry>

                <entry>Type</entry>

                <entry>Default</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>defaultLifetime</entry>

                <entry>Default lifetime in seconds of a cache entry if it is
                not specified for a specific entry on set()</entry>

                <entry>No</entry>

                <entry>integer</entry>

                <entry>3600</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>TYPO3\FLOW3\Cache\Backend\FileBackend</title>

      <para>The file backend stores every cache entry as a single file to the
      file system. The lifetime and tags are added after the data part in the
      same file.</para>

      <para>As main advantage the file backend is the only backend which
      implements the <interfacename>PhpCapableInterfac</interfacename> and can
      be used in combination with the <classname>PhpFrontend</classname>. The
      backend was specifically adapted to these needs and has low overhead for
      get and set operations, it scales very well with the number of entries
      for those operations. This mostly depends on the file lookup performance
      of the underlying file system in large directories, and most modern file
      systems use B-trees which can easily handle millions of files without
      much performance impact.</para>

      <para>A disadvantage is that the performance of
      <methodname>flushByTag()</methodname> is bad and scales just O(n). This
      basically means that with twice the number of entries the file backend
      needs double time to flush entries which are tagged with a given tag.
      This practically renders the file backend unusable for content caches.
      The reason for this design decision in FLOW3 is that the file backend is
      mainly used as AOP cache, where <methodname>flushByTag()</methodname> is
      only used if a PHP file changes. This happens very seldom on production
      systems, so get and set performance is much more important in this
      scenario.</para>

      <note>
        <para>Under heavy load the maximum <methodname>set()</methodname>
        performance depends on the maximum write and seek performance of the
        hard disk. If for example the server system shows lots of I/O wait in
        top, the file backend has reached this bound. A different storage
        strategy like RAM disks, battery backed up RAID systems or SSD hard
        disks might help then.</para>
      </note>

      <section>
        <title>Options</title>

        <para>The file backend has no options.</para>
      </section>
    </section>

    <section>
      <title>TYPO3\FLOW3\Cache\Backend\PdoBackend</title>

      <para>The PDO backend can be used as a native PDO interface to databases
      which are connected to PHP via PDO. The garbage collection is
      implemented for this backend and should be called to clean up hard disk
      space or memory.</para>

      <note>
        <para>There is currently very little production experience with this
        backend, especially not with a capable database like Oracle. We
        appreciate any feedback for real life use cases of this cache.</para>
      </note>

      <section>
        <title>Options</title>

        <table>
          <title>PdoBackend options</title>

          <tgroup cols="5">
            <colspec/>

            <colspec colwidth="4*"/>

            <colspec/>

            <colspec/>

            <colspec/>

            <thead>
              <row>
                <entry>Option</entry>

                <entry>Description</entry>

                <entry>Mandatory</entry>

                <entry>Type</entry>

                <entry>Default</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>dataSourceName</entry>

                <entry><para>Data source name for connecting to the database.
                Examples:<itemizedlist>
                    <listitem>
                      <para>mysql:host=localhost;dbname=test</para>
                    </listitem>

                    <listitem>
                      <para>sqlite:/path/to/sqlite.db</para>
                    </listitem>

                    <listitem>
                      <para>sqlite::memory:</para>
                    </listitem>
                  </itemizedlist></para></entry>

                <entry>Yes</entry>

                <entry>string</entry>

                <entry/>
              </row>

              <row>
                <entry>username</entry>

                <entry>Username to use for the database connection</entry>

                <entry>No</entry>

                <entry>string</entry>

                <entry/>
              </row>

              <row>
                <entry>password</entry>

                <entry>Password to use for the database connection</entry>

                <entry>No</entry>

                <entry>string</entry>

                <entry/>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>TYPO3\FLOW3\Cache\Backend\RedisBackend</title>

      <para><link ns5:href="http://redis.io/">Redis</link> is a key-value
      storage/database. In contrast to memcached, it allows structured values.
      Data is stored in RAM but it allows persistence to disk and doesn't
      suffer from the design problems which exist with the memcached backend
      implementation. The redis backend can be used as an alternative of the
      database backend for big cache tables and helps to reduce load on
      database servers this way. The implementation can handle millions of
      cache entries each with hundreds of tags if the underlying server has
      enough memory.</para>

      <para>Redis is known to be extremely fast but very memory hungry. The
      implementation is an option for big caches with lots of data because
      most important operations perform O(1) in proportion to the number of
      keys. This basically means that the access to an entry in a cache with a
      million entries is not slower than to a cache with only 10 entries, at
      least if there is enough memory available to hold the complete set in
      memory. At the moment only one redis server can be used at a time per
      cache, but one redis instance can handle multiple caches without
      performance loss when flushing a single cache.</para>

      <para>The garbage collection task should be run once in a while to find
      and delete old tags.</para>

      <para>The implementation is based on the <link
      ns5:href="https://github.com/owlient/phpredis">phpredis</link> module,
      which must be available on the system. It is recommended to build this
      from the git repository. Currently redis version 2.2 is
      recommended.</para>

      <para><note>
          <para>It is important to monitor the redis server and tune its
          settings to the specific caching needs and hardware capabilities.
          There are several articles on the net and the redis configuration
          file contains some important hints on how to speed up the system if
          it reaches bounds. A full documentation of available options is far
          beyond this documentation.</para>
        </note><warning>
          <para>The redis implementation is pretty young and should be
          considered as experimental. The redis project itself has a very high
          development speed and it might happen that the FLOW3 implementation
          changes to adapt to new versions.</para>
        </warning></para>

      <section>
        <title>Options</title>

        <table>
          <title>RedisBackend options</title>

          <tgroup cols="5">
            <colspec/>

            <colspec colwidth="4*"/>

            <colspec/>

            <colspec/>

            <colspec/>

            <thead>
              <row>
                <entry>Option</entry>

                <entry>Description</entry>

                <entry>Mandatory</entry>

                <entry>Type</entry>

                <entry>Default</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>host</entry>

                <entry>IP address or name of redis server to connect
                to.</entry>

                <entry>No</entry>

                <entry>string</entry>

                <entry>127.0.0.1</entry>
              </row>

              <row>
                <entry>port</entry>

                <entry>Port of the Redis server.</entry>

                <entry>Yes</entry>

                <entry>integer</entry>

                <entry>6379</entry>
              </row>

              <row>
                <entry>database</entry>

                <entry>Number of the database to store entries. Each cache
                should use its own database, otherwise all caches sharing a
                database are flushed if the flush operation is issued to one
                of them. Database numbers 0 and 1 are used and flushed by the
                core unit tests and should not be used if possible.</entry>

                <entry>No</entry>

                <entry>integer</entry>

                <entry>0</entry>
              </row>

              <row>
                <entry>password</entry>

                <entry>Password used to connect to the redis instance if the
                redis server needs authentication. Warning: The password is
                sent to the redis server in plain text.</entry>

                <entry>No</entry>

                <entry>string</entry>

                <entry/>
              </row>

              <row>
                <entry>compressionLevel</entry>

                <entry><para>Set gzip compression level to a specific value.
                The default compression level is usually
                sufficient.<variablelist>
                    <varlistentry>
                      <term>-1</term>

                      <listitem>
                        <para>Default gzip compression (recommended)</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term>0</term>

                      <listitem>
                        <para>No compression</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term>9</term>

                      <listitem>
                        <para>Maximum compression (but more CPU
                        overhead)</para>
                      </listitem>
                    </varlistentry>
                  </variablelist></para></entry>

                <entry>No</entry>

                <entry>integer (-1 to 9)</entry>

                <entry>-1</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>TYPO3\FLOW3\Cache\Backend\MemcachedBackend</title>

      <para><link ns5:href="http://memcached.org/">Memcached</link> is a
      simple key/value RAM database which scales across multiple servers. To
      use this backend, at least one memcache daemon must be reachable, and
      the PHP module memcache must be loaded. There are two PHP memcache
      implementations: memcache and memcached, only memcache is currently
      supported by this backend.</para>

      <section>
        <title>Warning and design constraints</title>

        <para>Memcached is by design a simple key-value store. Values must be
        strings and there is no relation between keys. Since the caching
        framework needs to put some structure in it to store the
        identifier-data-tags relations, it stores, for each cache entry, an
        identifier-to-data, an identifier-to-tags and a tag-to-identifiers
        entry.</para>

        <para>This leads to structural problems:<itemizedlist>
            <listitem>
              <para>If memcache runs out of memory but must store new entries,
              it will toss <emphasis>some</emphasis> other entry out of the
              cache (this is called an eviction in memcached speak).</para>
            </listitem>

            <listitem>
              <para>If data is shared over multiple memcache servers and some
              server fails, key/value pairs on this system will just vanish
              from cache.</para>
            </listitem>
          </itemizedlist>Both cases lead to corrupted caches: If, for example,
        a tags-to-identifier entry is lost,
        <methodname>dropByTag()</methodname> will not be able to find the
        corresponding identifier-to-data entries which should be removed and
        they will not be deleted. This results in old data delivered by the
        cache. Additionally, there is currently no implementation of the
        garbage collection which can rebuild cache integrity. It is thus
        important to monitor a memcached system for evictions and server
        outages and to clear clear caches if that happens.</para>

        <para>Furthermore memcache has no sort of namespacing. To distinguish
        entries of multiple caches from each other, every entry is prefixed
        with the cache name. This can lead to very long runtimes if a big
        cache needs to be flushed, because every entry has to be handled
        separately and it is not possible to just truncate the whole cache
        with one call as this would clear the whole memcached data which might
        even hold non FLOW3 related entries.</para>

        <para>Because of the mentioned drawbacks, the memcached backend should
        be used with care or in situations where cache integrity is not
        important or if a cache has no need to use tags at all.</para>

        <note>
          <para>The current native debian squeeze package (probably other
          distributions are affected, too) suffers from <link
          ns5:href="http://pecl.php.net/bugs/bug.php?id=16927">PHP memcache
          bug #16927</link>.</para>
        </note>

        <note>
          <para>Since memcached has no sort of namespacing and access control,
          this backend should not be used if other third party systems do have
          access to the same memcached daemon for security reasons. This is a
          typical problem in cloud deployments where access to memcache is
          cheap (but could be read by third parties) and access to databases
          is expensive.</para>
        </note>
      </section>

      <section>
        <title>Options</title>

        <table>
          <title>MemcachedBackend options</title>

          <tgroup cols="5">
            <colspec/>

            <colspec colwidth="4*"/>

            <colspec/>

            <colspec/>

            <colspec/>

            <thead>
              <row>
                <entry>Option</entry>

                <entry>Description</entry>

                <entry>Mandatory</entry>

                <entry>Type</entry>

                <entry>Default</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>servers</entry>

                <entry><para>Array of used memcached servers, at least one
                server must be defined. Each server definition is a string,
                allowed syntaxes:<variablelist>
                    <varlistentry>
                      <term>host</term>

                      <listitem>
                        <para>TCP connect to host on memcached default port
                        (usually 11211, defined by PHP ini variable
                        memcache.default_port)</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term>host:port</term>

                      <listitem>
                        <para>TCP connect to host on port</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term>tcp://hostname:port</term>

                      <listitem>
                        <para>Same as above</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term>unix:///path/to/memcached.sock</term>

                      <listitem>
                        <para>Connect to memcached server using unix
                        sockets</para>
                      </listitem>
                    </varlistentry>
                  </variablelist></para></entry>

                <entry>Yes</entry>

                <entry>array</entry>

                <entry/>
              </row>

              <row>
                <entry>compression</entry>

                <entry>Enable memcached internal data compression. Can be used
                to reduce memcached memory consumption but adds additional
                compression / decompression CPU overhead on the according
                memcached servers.</entry>

                <entry>No</entry>

                <entry>boolean</entry>

                <entry>FALSE</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>TYPO3\FLOW3\Cache\Backend\ApcBackend</title>

      <para><link ns5:href="http://pecl.php.net/package/APC">APC</link> is
      mostly known as an opcode cache for PHP source files but can be used to
      store user data as well. As main advantage the data can be shared
      between different PHP processes and requests. All calls are direct
      memory calls. This makes this backend lightning fast for get() and set()
      operations. It can be an option for relatively small caches (few dozens
      of megabytes) which are read and written very often and becomes handy if
      APC is used as opcode cache anyway.</para>

      <para>The implementation is very similar to the memcached backend
      implementation and suffers from the same problems if APC runs out of
      memory.</para>

      <para>The garbage collection is currently not implemented. In its latest
      version, APC will fail to store data with a <link
      ns5:href="http://pecl.php.net/bugs/bug.php?id=16966">PHP warning</link>
      if it runs out of memory. This may change in the future. Even without
      using the cache backend, it is adviseable to increase the memory cache
      size of APC to at least 64MB when working with FLOW3, simply due to the
      large number of PHP files to be cached. A minimum of 128MB is
      recommended when using the additional content cache. Cache TTL for file
      and user data should be set to zero (disabled) to avoid heavy memory
      fragmentation.</para>

      <note>
        <para>It is not advisable to use the APC backend in shared hosting
        environments for security reasons: The user cache in APC is not aware
        of different virtual hosts. Basically every PHP script which is
        executed on the system can read and write any data to this shared
        cache, given data is not encapsulated or namespaced in any way. Only
        use the APC backend in environments which are completely under your
        control and where no third party can read or tamper your data.</para>
      </note>

      <section>
        <title>Options</title>

        <para>The APC backend has no options.</para>
      </section>
    </section>

    <section>
      <title>TYPO3\FLOW3\Cache\Backend\TransientMemoryBackend</title>

      <para>The transient memory backend stores data in a local array. It is
      only valid for one request. This becomes handy if code logic needs to do
      expensive calculations or must look up identical information from a
      database over and over again during its execution. In this case it is
      useful to store the data in an array once and just lookup the entry from
      the cache for consecutive calls to get rid of the otherwise additional
      overhead. Since caches are available system wide and shared between core
      and extensions they can profit from each other if they need the same
      information.</para>

      <para>Since the data is stored directly in memory, this backend is the
      quickest backend available. The stored data adds to the memory consumed
      by the PHP process and can hit the <option>memory_limit</option> PHP
      setting.</para>

      <section>
        <title>Options</title>

        <para>The transient memory backend has no options.</para>
      </section>
    </section>

    <section>
      <title>TYPO3\FLOW3\Cache\Backend\NullBackend</title>

      <para>The null backend is a dummy backend which doesn't store any data
      and always returns <constant>FALSE</constant> on
      <methodname>get()</methodname>.</para>

      <section>
        <title>Options</title>

        <para>The null backend has no options.</para>
      </section>
    </section>
  </section>

  <section>
    <title>How to use the caching framework</title>

    <para>This section is targeted at developers who want to use caches for
    arbitrary needs. It is only about proper initialization, not a discussion
    about identifier, tagging and lifetime decisions that must be taken during
    development.</para>

    <section>
      <title>Register a cache</title>

      <para>To register a cache it must be configured in
      <filename>Caches.yaml</filename> of a package:<programlisting
      language="yaml">MyPackage_FooCache:
  frontend: TYPO3\FLOW3\Cache\Frontend\StringFrontend
</programlisting>In this case
      <classname>\TYPO3\FLOW3\Cache\Frontend\StringFrontend</classname> was
      chosen, but that depends on individual needs. This setting is usually
      not changed by users. Any option not given is inherited from the
      configuration of the "Default" cache. The name
      (<literal>MyPackage_FooCache</literal> in this case) can be chosen
      freely, but keep possible name clashes in mind and adopt a meaningful
      schema.</para>
    </section>

    <section>
      <title>Retrieve and use a cache</title>

      <section>
        <title>Using depdendency injection</title>

        <para>A cache is usually retrieved through dependency injection,
        either constructor or setter injection. Which is chosen depends on
        when you need the cache to be available. Keep in mind that even if you
        seem to need a cache in the constructor, you could always make use of
        <methodname>initializeObject()</methodname>. Here is an example for
        setter injection matching the configuration given above. First you
        need to configure the injection in
        <filename>Settings.yaml</filename>:<programlisting language="yaml">MyCompany\MyPackage\SomeClass:
  properties:
    fooCache:
      object:
        factoryObjectName: TYPO3\FLOW3\Cache\CacheManager
        factoryMethodName: getCache
        arguments:
          1:
            value: MyPackage_FooCache
</programlisting>This configures what will be injected into the following
        setter:<programlisting language="php">/**
 * Sets the foo cache
 *
 * @param \TYPO3\FLOW3\Cache\Frontend\StringFrontend $cache Cache for foo data
 * @return void
 */
public function setFooCache(\TYPO3\FLOW3\Cache\Frontend\StringFrontend $cache) {
	$this-&gt;fooCache = $cache;
}
</programlisting>To make it even simpler you could omit the setter method and
        annotate the member with <literal>@inject</literal>. The injected
        cache is fully initialized, all available frontend operations like
        <methodname>get()</methodname>, <methodname>set()</methodname> and
        <methodname>flushByTag()</methodname> can be executed on
        <varname>$this-&gt;fooCache</varname>.</para>
      </section>

      <section>
        <title>Using the CacheFactory</title>

        <para>Of course you can also manually ask the CacheManager (have it
        injected for your convenience) for a cache:<programlisting
        language="php">$this-&gt;fooCache = $this-&gt;cacheManager-&gt;getCache('MyPackage_FooCache');</programlisting></para>
      </section>
    </section>
  </section>
</chapter>
